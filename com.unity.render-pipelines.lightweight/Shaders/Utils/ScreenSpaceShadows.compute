
#pragma kernel BlendDynamicShadowsNoFilter  CSMain=BlendDynamicShadowsNoFilter  WITH_DYNAMIC_SHADOWS NO_FILTERING
#pragma kernel BlendDynamicShadowsBilinear  CSMain=BlendDynamicShadowsBilinear  WITH_DYNAMIC_SHADOWS BILINEAR_FILTERING
#pragma kernel BlendDynamicShadowsTrilinear CSMain=BlendDynamicShadowsTrilinear WITH_DYNAMIC_SHADOWS TRILINEAR_FILTERING

#pragma kernel NoBlendNoFilter              CSMain=NoBlendNoFilter              NO_FILTERING
#pragma kernel NoBlendBilinear              CSMain=NoBlendBilinear              BILINEAR_FILTERING
#pragma kernel NoBlendTrilinear             CSMain=NoBlendTrilinear             TRILINEAR_FILTERING

#define TILE_SIZE 8

#define _SHADOWS_ENABLED
#define _MAIN_LIGHT_SHADOWS_CASCADE

//#define USE_IMITATED_CLZ
#define USE_EMULATE_CLZ
#define USE_EMULATE_COUNTBITS

#define DO_RETRAVERSAL
//#define VISUALIZE_TRAVERSAL
//#define VISUALIZE_LOOP


#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Input.hlsl"
#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl"

#ifdef UNITY_MATRIX_I_VP
#undef UNITY_MATRIX_I_VP
#endif


#define UNITY_MATRIX_I_VP _InvViewProjMatrix

#if defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
TEXTURE2D_ARRAY_FLOAT(_CameraDepthTexture);
#else
TEXTURE2D_FLOAT(_CameraDepthTexture);
#endif

SAMPLER(sampler_CameraDepthTexture);

CBUFFER_START(_DirectionalVxShadowMap)
uint _VoxelResolution;
int _VoxelZBias;
float _VoxelUpBias;
uint _MaxScale;
float4x4 _WorldToShadowMatrix;
CBUFFER_END

StructuredBuffer<uint> _VxShadowMapBuffer;
RW_TEXTURE2D(float, _ScreenSpaceShadowOutput);


uint emulateCLZ(uint x)
{
    // emulate it similar to count leading zero.
    // count leading 1bit.

    uint n = 32;
    uint y;

    y = x >> 16; if (y != 0) { n = n - 16; x = y; }
    y = x >>  8; if (y != 0) { n = n -  8; x = y; }
    y = x >>  4; if (y != 0) { n = n -  4; x = y; }
    y = x >>  2; if (y != 0) { n = n -  2; x = y; }
    y = x >>  1; if (y != 0) return n - 2;

    return n - x;
}

uint imitateCLZ(uint srcPosbit, uint dstPosbit)
{
    int i = _MaxScale;
    for (; i > 1; --i)
    {
        uint shift = i - 1;

        uint a = (srcPosbit >> shift) & 0x00000001;
        uint b = (dstPosbit >> shift) & 0x00000001;

        if (a != b)
            break;
    }

    return i;
}

uint countBits(uint i)
{
#ifdef USE_EMULATE_COUNTBITS
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);

    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
#else
    return countbits(i);
#endif
}

uint4 countBits(uint4 i)
{
#ifdef USE_EMULATE_COUNTBITS
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);

    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
#else
    return countbits(i);
#endif
}

// todo : calculate uint2 and uint2
uint CalculateRescale(uint srcPosbit, uint dstPosbit)
{
#if defined USE_EMULATE_CLZ
    uint disparity = 32 - emulateCLZ(srcPosbit ^ dstPosbit);
#elif defined USE_IMITATED_CLZ
    uint disparity = imitateCLZ(srcPosbit, dstPosbit);
#else
    uint disparity = _MaxScale;
#endif

    return disparity;
}

void TraverseVxShadowMapPosQ(uint3 posQ, out uint4 result)
{
    uint nodeIndex = 0;
    uint scale = _MaxScale;

    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countBits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    result = uint4(nodeIndex, lit, shadowed, intersected);
}

void TraverseVxShadowMapPosQ2x2(uint3 posQ_0, out uint4 results[4])
{
    uint3 posQ_1 = posQ_0 + uint3(1, 0, 0);
    uint3 posQ_2 = posQ_0 + uint3(0, 1, 0);
    uint3 posQ_3 = posQ_0 + uint3(1, 1, 0);

    uint4 nodeIndex4 = 0;
    uint scale = _MaxScale;

    bool4 lit4 = false;
    bool4 shadowed4 = false;
    bool4 intersected4 = true;

    for (; scale > 3 && any(intersected4); --scale)
    {
        // calculate where to go to child
        uint3 childDet_0 = (posQ_0 >> (scale - 1)) & 0x00000001;
        uint3 childDet_1 = (posQ_1 >> (scale - 1)) & 0x00000001;
        uint3 childDet_2 = (posQ_2 >> (scale - 1)) & 0x00000001;
        uint3 childDet_3 = (posQ_3 >> (scale - 1)) & 0x00000001;

        uint4 cellShift4 = uint4(
            (childDet_0.x << 1) + (childDet_0.y << 2) + (childDet_0.z << 3),
            (childDet_1.x << 1) + (childDet_1.y << 2) + (childDet_1.z << 3),
            (childDet_2.x << 1) + (childDet_2.y << 2) + (childDet_2.z << 3),
            (childDet_3.x << 1) + (childDet_3.y << 2) + (childDet_3.z << 3));

        uint4 cellbit4 = 0x00000003 << cellShift4;

        // calculate bit
        uint4 header4 = uint4(
            _VxShadowMapBuffer[nodeIndex4.x],
            _VxShadowMapBuffer[nodeIndex4.y],
            _VxShadowMapBuffer[nodeIndex4.z],
            _VxShadowMapBuffer[nodeIndex4.w]);
        uint4 childmask4 = header4 >> 16;
        uint4 shadowbit4 = (childmask4 & cellbit4) >> cellShift4;

        // determine whether it is lit or shadowed.
        lit4 = intersected4 ? shadowbit4 & 0x00000001 : lit4;
        shadowed4 = intersected4 ? shadowbit4 & 0x00000002 : shadowed4;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected4 = lit4 && shadowed4;

        // find next child node
        uint4 mask4 = ~(0xFFFFFFFF << cellShift4);
        uint4 childrenbit4 = childmask4 & ((childmask4 & 0x0000AAAA) >> 1);
        uint4 childIndex4 = countBits(childrenbit4 & mask4);
        uint4 nextIndex4 = nodeIndex4 + 1 + childIndex4;

        // go down to the next node
        nodeIndex4.x = intersected4.x ? _VxShadowMapBuffer[nextIndex4.x] : nodeIndex4.x;
        nodeIndex4.y = intersected4.y ? _VxShadowMapBuffer[nextIndex4.y] : nodeIndex4.y;
        nodeIndex4.z = intersected4.z ? _VxShadowMapBuffer[nextIndex4.z] : nodeIndex4.z;
        nodeIndex4.w = intersected4.w ? _VxShadowMapBuffer[nextIndex4.w] : nodeIndex4.w;
    }

    results[0] = uint4(nodeIndex4.x, lit4.x, shadowed4.x, intersected4.x);
    results[1] = uint4(nodeIndex4.y, lit4.y, shadowed4.y, intersected4.y);
    results[2] = uint4(nodeIndex4.z, lit4.z, shadowed4.z, intersected4.z);
    results[3] = uint4(nodeIndex4.w, lit4.w, shadowed4.w, intersected4.w);
}

void TraverseVxShadowMapPosQ(uint3 posQ, out uint4 result, out uint scale, out uint nodeTracer[16])
{
    uint nodeIndex = 0;

    scale = _MaxScale;

    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // push node index
        uint tracerIndex = scale - 4;
        nodeTracer[tracerIndex] = nodeIndex;

        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countBits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    result =  uint4(nodeIndex, lit, shadowed, intersected);
}

void RetraverseVxShadowMapPosQ(uint scale, uint nodeIndex, uint3 posQ, out uint4 result)
{
    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit   = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countBits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    result = uint4(nodeIndex, lit, shadowed, intersected);
}

uint2 TraverseVxShadowMapLeaf(uint posQ_z, uint4 innerResult)
{
    uint nodeIndex   = innerResult.x;

    bool lit         = innerResult.y;
    bool intersected = innerResult.w;

    uint bitmask0 = lit ? 0x00000000 : 0xFFFFFFFF;
    uint bitmask1 = lit ? 0x00000000 : 0xFFFFFFFF;

    if (intersected)
    {
        int childIndex = posQ_z % 8;
        int leafIndex = _VxShadowMapBuffer[nodeIndex + childIndex];

        bitmask0 = _VxShadowMapBuffer[leafIndex];
        bitmask1 = _VxShadowMapBuffer[leafIndex + 1];
    }

    return uint2(bitmask0, bitmask1);
}

// for one x-y-z-step
uint2 RetraversalVxShadowMapLeaf(uint3 posQ, uint3 offset, uint rescale, uint scale, uint2 bitmask2, uint nodeTracer[16])
{
#ifdef DO_RETRAVERSAL
    if (rescale <= scale)
        return bitmask2;

    uint nodeIndex = nodeTracer[rescale - 4];
    uint4 result;

    RetraverseVxShadowMapPosQ(rescale, nodeIndex, posQ + offset, result);
    bitmask2 = TraverseVxShadowMapLeaf(posQ.z + offset.z, result);
#endif

    return bitmask2;
}

// only for one z-step
uint2 RetraversalVxShadowMapLeafOneZStep(uint3 posQ, uint rescale, uint scale, uint4 result, uint nodeTracer[16])
{
#ifdef DO_RETRAVERSAL
    if (rescale <= scale)
        return TraverseVxShadowMapLeaf(posQ.z + 1, result);

    uint nodeIndex = nodeTracer[rescale - 4];
    RetraverseVxShadowMapPosQ(rescale, nodeIndex, posQ + uint3(0, 0, 1), result);
#endif

    return TraverseVxShadowMapLeaf(posQ.z + 1, result);
}

float PointSampleShadowBitmask(uint2 bitmask2, uint3 posQ)
{
    uint2 posLeaf = posQ.xy % uint2(8, 8);
    uint bitmask = posLeaf.y < 4 ? bitmask2.x : bitmask2.y;

    uint shift = posLeaf.x + 8 * (posLeaf.y % 4);
    uint mask = 0x00000001 << shift;

    float litRate = (bitmask & mask) == 0 ? 1.0 : 0.0;

    return litRate;
}

float PointSampleShadowBitmask(uint2 bitmask2, uint3 posQ, uint2 offset)
{
    uint2 posLeaf = (posQ.xy + offset) % uint2(8, 8);
    uint bitmask = posLeaf.y < 4 ? bitmask2.x : bitmask2.y;

    uint shift = posLeaf.x + 8 * (posLeaf.y % 4);
    uint mask = 0x00000001 << shift;

    float litRate = (bitmask & mask) == 0 ? 1.0 : 0.0;

    return litRate;
}

float BilinearSampleShadowBitmask(uint3 posQ, uint2 bitmask2_00, uint2 bitmask2_10, uint2 bitmask2_01, uint2 bitmask2_11, float2 lerpWeight)
{
#if 1 // second opt
    uint4 posLeaf_x = (posQ.xxxx + uint4(0, 1, 0, 1)) % 8;
    uint4 posLeaf_y = (posQ.yyyy + uint4(0, 0, 1, 1)) % 8;

    uint4 bitmask_x = uint4(bitmask2_00.x, bitmask2_10.x, bitmask2_01.x, bitmask2_11.x);
    uint4 bitmask_y = uint4(bitmask2_00.y, bitmask2_10.y, bitmask2_01.y, bitmask2_11.y);

    uint4 bitmask = posLeaf_y < 4 ? bitmask_x : bitmask_y;
    uint4 shift = posLeaf_x + 8 * (posLeaf_y % 4);

    uint4 mask = 0x00000001 << shift;

    float4 attenuation = (bitmask & mask) == 0 ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 0.0);

    attenuation.x = lerp(attenuation.x, attenuation.y, lerpWeight.x);
    attenuation.y = lerp(attenuation.z, attenuation.w, lerpWeight.x);

    return lerp(attenuation.x, attenuation.y, lerpWeight.y);

#elif 0 // first opt
    uint2 posLeaf_00 = posQ.xy % uint2(8, 8);
    uint2 posLeaf_10 = uint2(posQ.x + 1, posQ.y) % uint2(8, 8);
    uint2 posLeaf_01 = uint2(posQ.x, posQ.y + 1) % uint2(8, 8);
    uint2 posLeaf_11 = (posQ.xy + 1) % uint2(8, 8);

    uint4 bitmask = uint4(
        posLeaf_00.y < 4 ? bitmask2_00.x : bitmask2_00.y,
        posLeaf_10.y < 4 ? bitmask2_10.x : bitmask2_10.y,
        posLeaf_01.y < 4 ? bitmask2_01.x : bitmask2_01.y,
        posLeaf_11.y < 4 ? bitmask2_11.x : bitmask2_11.y);

    uint4 shift = uint4(
        posLeaf_00.x + 8 * (posLeaf_00.y % 4),
        posLeaf_10.x + 8 * (posLeaf_10.y % 4),
        posLeaf_01.x + 8 * (posLeaf_01.y % 4),
        posLeaf_11.x + 8 * (posLeaf_11.y % 4));

    uint4 mask = 0x00000001 << shift;

    float4 attenuation = (bitmask & mask) == 0 ? float4(1.0, 1.0, 1.0, 1.0) : float4(0.0, 0.0, 0.0, 0.0);

    attenuation.x = lerp(attenuation.x, attenuation.y, lerpWeight.x);
    attenuation.y = lerp(attenuation.z, attenuation.w, lerpWeight.x);

    return lerp(attenuation.x, attenuation.y, lerpWeight.y);
#else // origin
    float attenuation0 = PointSampleShadowBitmask(bitmask2_00, posQ);
    float attenuation1 = PointSampleShadowBitmask(bitmask2_10, posQ, uint2(1, 0));
    float attenuation2 = PointSampleShadowBitmask(bitmask2_01, posQ, uint2(0, 1));
    float attenuation3 = PointSampleShadowBitmask(bitmask2_11, posQ, uint2(1, 1));

    attenuation0 = lerp(attenuation0, attenuation1, lerpWeight.x);
    attenuation1 = lerp(attenuation2, attenuation3, lerpWeight.x);

    return lerp(attenuation0, attenuation1, lerpWeight.y);
#endif
}

float ComputeVxShadowMapAttenuationNoFiltering(float3 positionWS)
{
    positionWS.y += _VoxelUpBias;
    float3 posNDC = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;
    float3 posP = posNDC * (float)_VoxelResolution;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelZBias;

    if (any(posQ >= (_VoxelResolution.xxx - 1)))
        return 1.0;

    uint4 result;
    TraverseVxShadowMapPosQ(posQ, result);

    if (result.w == 0)
#ifdef VISUALIZE_TRAVERSAL
        return result.y ? 0.75 : 0.25;
#else
        return result.y ? 1.0 : 0.0;
#endif

    uint2 bitmask2 = TraverseVxShadowMapLeaf(posQ.z, result);
    float attenuation = PointSampleShadowBitmask(bitmask2, posQ);

    return attenuation;
}

float ComputeVxShadowMapAttenuationBiFiltering(float3 positionWS)
{
    positionWS.y += _VoxelUpBias;
    float3 posNDC = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    float3 posP = posNDC * (float)_VoxelResolution - 0.5;
    float3 posF = floor(posP);
    float2 lerpWeight = posP.xy - posF.xy;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelZBias;

    if (any(posQ >= (_VoxelResolution.xxx - 1)))
        return 1.0;

    uint scale = 0;
    uint nodeTracer[16];

    uint4 result;
    TraverseVxShadowMapPosQ(posQ, result, scale, nodeTracer);

    uint2 edgeQ = uint2(1, 1) << scale;
    bool2 inner = (posQ.xy % edgeQ) < (edgeQ - 1);

    if (all(inner) && result.w == 0)
#ifdef VISUALIZE_TRAVERSAL
        return result.y ? 0.75 : 0.25;
#else
        return result.y ? 1.0 : 0.0;
#endif

    uint2 rescale = uint2(
        CalculateRescale(posQ.x, posQ.x + 1),
        CalculateRescale(posQ.y, posQ.y + 1));

    uint maxRescale = max(rescale.x, rescale.y);

    // todo : reduce traversal count by storing node tracer at each retraversal function
    uint2 bitmask2_00 = TraverseVxShadowMapLeaf(posQ.z, result);
    uint2 bitmask2_10 = RetraversalVxShadowMapLeaf(posQ, uint3(1, 0, 0), rescale.x, scale, bitmask2_00, nodeTracer);
    uint2 bitmask2_01 = RetraversalVxShadowMapLeaf(posQ, uint3(0, 1, 0), rescale.y, scale, bitmask2_00, nodeTracer);
    uint2 bitmask2_11 = RetraversalVxShadowMapLeaf(posQ, uint3(1, 1, 0), maxRescale, scale, bitmask2_00, nodeTracer);

    return BilinearSampleShadowBitmask(posQ, bitmask2_00, bitmask2_10, bitmask2_01, bitmask2_11, lerpWeight.xy);
}

float ComputeVxShadowMapAttenuationTriFiltering(float3 positionWS)
{
    positionWS.y += _VoxelUpBias;
    float3 posNDC = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    float3 posP = posNDC * _VoxelResolution - 0.5;
    float3 posF = floor(posP);
    float3 lerpWeight = posP - posF;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelZBias;

    if (any(posQ >= (_VoxelResolution.xxx - 1)))
        return 1.0;

    uint scale = 0;
    uint nodeTracer[16];

    uint4 result;
    TraverseVxShadowMapPosQ(posQ, result, scale, nodeTracer);

    uint3 edgeQ = uint3(1, 1, 1) << scale;
    bool3 inner = (posQ % edgeQ) < (edgeQ - 1);

    if (all(inner) && result.w == 0)
#ifdef VISUALIZE_TRAVERSAL
        return result.y ? 0.75 : 0.25;
#else
        return result.y ? 1.0 : 0.0;
#endif

    uint3 rescale = uint3(
        CalculateRescale(posQ.x, posQ.x + 1),
        CalculateRescale(posQ.y, posQ.y + 1),
        CalculateRescale(posQ.z, posQ.z + 1));

    uint maxRescale = max(rescale.x, rescale.y);

    // todo : reduce traversal count by storing node tracer at each retraversal function
    uint2 bitmask2_00 = TraverseVxShadowMapLeaf(posQ.z, result);
    uint2 bitmask2_10 = RetraversalVxShadowMapLeaf(posQ, uint3(1, 0, 0), rescale.x, scale, bitmask2_00, nodeTracer);
    uint2 bitmask2_01 = RetraversalVxShadowMapLeaf(posQ, uint3(0, 1, 0), rescale.y, scale, bitmask2_00, nodeTracer);
    uint2 bitmask2_11 = RetraversalVxShadowMapLeaf(posQ, uint3(1, 1, 0), maxRescale, scale, bitmask2_00, nodeTracer);

    float attenuation_z0 = BilinearSampleShadowBitmask(posQ, bitmask2_00, bitmask2_10, bitmask2_01, bitmask2_11, lerpWeight.xy);

    uint maxRescale1 = max(rescale.z, rescale.x);
    uint maxRescale2 = max(rescale.z, rescale.y);
    uint maxRescale3 = max(rescale.z, maxRescale);

    // todo : reduce traversal count by storing node tracer at each retraversal function
    bitmask2_00 = RetraversalVxShadowMapLeafOneZStep(posQ, rescale.z, scale, result, nodeTracer);
    bitmask2_10 = RetraversalVxShadowMapLeaf(posQ, uint3(1, 0, 1), maxRescale1, scale, bitmask2_00, nodeTracer);
    bitmask2_01 = RetraversalVxShadowMapLeaf(posQ, uint3(0, 1, 1), maxRescale2, scale, bitmask2_00, nodeTracer);
    bitmask2_11 = RetraversalVxShadowMapLeaf(posQ, uint3(1, 1, 1), maxRescale3, scale, bitmask2_00, nodeTracer);

    float attenuation_z1 = BilinearSampleShadowBitmask(posQ, bitmask2_00, bitmask2_10, bitmask2_01, bitmask2_11, lerpWeight.xy);

    return lerp(attenuation_z0, attenuation_z1, lerpWeight.z);
}

float SampleVxShadowMap(float3 positionWS)
{
    float attenuation = 1.0;

#if NO_FILTERING
    attenuation = ComputeVxShadowMapAttenuationNoFiltering(positionWS);
#elif BILINEAR_FILTERING
    attenuation = ComputeVxShadowMapAttenuationBiFiltering(positionWS);
#elif TRILINEAR_FILTERING
    attenuation = ComputeVxShadowMapAttenuationTriFiltering(positionWS);
#elif PCF9X9_FILTERING
    //attenuation = ComputeVxShadowMapAttenuationPCF9x9iltering(positionWS);
#endif

    return attenuation;
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void CSMain(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    uint2 pixelCoord = groupId * TILE_SIZE + groupThreadId;
    uint2 tileCoord = groupId;

    if (any(pixelCoord.xy >= (uint2)_ScreenSize.xy))
        return;

    float depth = LOAD_TEXTURE2D(_CameraDepthTexture, pixelCoord).x;

    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _ScreenSpaceShadowOutput[pixelCoord] = 1.0;
        return;
    }

    // if depth is not reversed
#if !UNITY_REVERSED_Z
    // todo : find the way to work on OpenGLES 3.1+ on mobile
    //depth = depth * 2.0 - 1.0; OpenGLCore
#endif

#if 0
    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, tileCoord);
    float3 positionWS = posInput.positionWS;
#else
    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, tileCoord);
    float3 positionWS = ComputeWorldSpacePosition(posInput.positionNDC, depth, UNITY_MATRIX_I_VP);
#endif

    float shadowStrength = GetMainLightShadowStrength();
    float attenuation = 1.0;

#if 1// WIP for optimization

#if WITH_DYNAMIC_SHADOWS
    float4 shadowMapCoords = TransformWorldToShadowCoord(positionWS);

    ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
    attenuation = SampleShadowmap(shadowMapCoords, TEXTURE2D_PARAM(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), shadowSamplingData, 1.0, false);

    if (attenuation == 0.0)
    {
        _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);
        return;
    }
#endif

    #if NO_FILTERING

    positionWS.y += _VoxelUpBias;
    float3 posNDC = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;
    float3 posP = posNDC * (float)_VoxelResolution;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelZBias;

    if (any(posQ >= (_VoxelResolution.xxx - 1)))
    {
        _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);
        return;
    }

    uint nodeIndex = 0;
    uint scale = _MaxScale;

    bool lit = false;
    bool shadowed = false;
    bool intersected = true;

    for (; scale > 3 && intersected; --scale)
    {
        // calculate where to go to child
        uint3 childDet = (posQ >> (scale - 1)) & 0x00000001;
        uint cellShift = (childDet.x << 1) + (childDet.y << 2) + (childDet.z << 3);
        uint cellbit = 0x00000003 << cellShift;

        // calculate bit
        uint header = _VxShadowMapBuffer[nodeIndex];
        uint childmask = header >> 16;
        uint shadowbit = (childmask & cellbit) >> cellShift;

        // determine whether it is lit or shadowed.
        lit      = shadowbit & 0x00000001;
        shadowed = shadowbit & 0x00000002;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        intersected = lit && shadowed;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countbits(childrenbit & mask);

        // go down to the next node
        nodeIndex = _VxShadowMapBuffer[nodeIndex + 1 + childIndex];
    }

    if (intersected == false)
    {
        attenuation = min(attenuation, lit ? 1.0 : 0.0);
#ifdef VISUALIZE_TRAVERSAL
        attenuation = lit ? 0.75 : 0.25;
#endif
        _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);
        return;
    }

    uint3 leaf = posQ % uint3(8, 8, 8);
    uint leafIndex = _VxShadowMapBuffer[nodeIndex + leaf.z];

    uint bitmask0 = _VxShadowMapBuffer[leafIndex];
    uint bitmask1 = _VxShadowMapBuffer[leafIndex + 1];
    uint bitmask = leaf.y < 4 ? bitmask0 : bitmask1;

    uint maskShift = leaf.x + 8 * (leaf.y % 4);
    uint mask = 0x00000001 << maskShift;

    attenuation = (bitmask & mask) == 0 ? 1.0 : 0.0;
    _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);

    #elif BILINEAR_FILTERING

    positionWS.y += _VoxelUpBias;
    float3 posNDC = mul(_WorldToShadowMatrix, float4(positionWS, 1.0)).xyz;

    float3 posP = posNDC * (float)_VoxelResolution - 0.5;
    float3 posF = floor(posP);
    float2 lerpWeight = posP.xy - posF.xy;

    uint3 posQ = (uint3)posP;
    posQ.z -= _VoxelZBias;

    if (any(posQ >= (_VoxelResolution.xxx - 1)))
    {
        _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(1.0, shadowStrength);
        return;
    }

    uint4 results[4];
    TraverseVxShadowMapPosQ2x2(posQ, results);

    if (results[0].w == 0 && results[1].w == 0 && results[2].w == 0 && results[3].w == 0)
    {
        attenuation = min(attenuation, results[0].y ? 1.0 : 0.0);
#ifdef VISUALIZE_TRAVERSAL
        attenuation = results[0].y ? 0.75 : 0.25;
#endif
        _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);
        return;
    }

    uint2 bitmask2_00 = TraverseVxShadowMapLeaf(posQ.z, results[0]);
    uint2 bitmask2_10 = TraverseVxShadowMapLeaf(posQ.z, results[1]);
    uint2 bitmask2_01 = TraverseVxShadowMapLeaf(posQ.z, results[2]);
    uint2 bitmask2_11 = TraverseVxShadowMapLeaf(posQ.z, results[3]);

    attenuation = min(attenuation, BilinearSampleShadowBitmask(posQ, bitmask2_00, bitmask2_10, bitmask2_01, bitmask2_11, lerpWeight.xy));
    _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);

    #endif
#else
#if WITH_DYNAMIC_SHADOWS
    float4 shadowMapCoords = TransformWorldToShadowCoord(positionWS);

    ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
    attenuation = SampleShadowmap(shadowMapCoords, TEXTURE2D_PARAM(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), shadowSamplingData, 1.0, false);

    if (attenuation == 0.0)
    {
        _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);
        return;
    }
#endif

    attenuation = min(attenuation, SampleVxShadowMap(positionWS));

    _ScreenSpaceShadowOutput[pixelCoord] = LerpWhiteTo(attenuation, shadowStrength);
#endif
}
