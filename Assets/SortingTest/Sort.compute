#pragma kernel BitonicSort BITONIC_SORT
//#pragma kernel MergeSort MERGE_SORT
#pragma kernel MergePass

#include "HLSLSupport.cginc"

#define ELEMENTS_COUNT 1024

// More loads per threads. Can reduce stall time due to barriers
// Needs a good occupancy in the first place (many groups dispatched)
#define ITERATIONS_COUNT 2

// This allows to reduce bank conflicts by adding an additional dword every LDS_PADDING_PERIOD
// (Watch out for occupancy though)
// 0 to deactivate padding
#if BITONIC_SORT
#define LDS_PADDING_PERIOD 32
#else
#define LDS_PADDING_PERIOD 0
#endif

// 1 to use the alternative representation of the bitonic network: 
// No comparison flipping but dedicated first sub pass.
// see https://en.wikipedia.org/wiki/Bitonic_sorter 
#define USE_ALTERNATE_BITONIC_NETWORK 0

// For final pass we dont need to output key/value pairs but only sorted values
#define FINAL_PASS 0

#define BITONIC_THREADS_COUNT ELEMENTS_COUNT / (2 * ITERATIONS_COUNT)
#define MERGE_THREADS_COUNT ELEMENTS_COUNT

#if LDS_PADDING_PERIOD
#define HALF_SCRATCH_SIZE (ELEMENTS_COUNT + ELEMENTS_COUNT / LDS_PADDING_PERIOD)
#else
#define HALF_SCRATCH_SIZE ELEMENTS_COUNT
#endif

#define LDS_VALUES_OFFSET HALF_SCRATCH_SIZE //((HALF_SCRATCH_SIZE + 31) & ~32)
#define SCRATCH_SIZE (HALF_SCRATCH_SIZE << 1)

// TODO Test other accesses pattern for iterations
#define ITERATION_INDEX(id,it) ((it) * BITONIC_THREADS_COUNT + (id))
#define DST_INDEX(groupId,threadId) (groupId * BITONIC_THREADS_COUNT * ITERATIONS_COUNT + threadId)

#define MAX_FLOAT asfloat(0x7f7fffff)

struct KVP
{
	float key;
	uint value;
};

StructuredBuffer<KVP> inputSequence;
#if FINAL_PASS
RWStructuredBuffer<uint> sortedSequence;
#else
RWStructuredBuffer<KVP> sortedSequence;
#endif

// Layout of the scratch memory is as follows:
// First all keys (potentially padded by a DWORD every LDS_PADDING_PERIOD
// Then all values with the same padding pattern
groupshared float scratch[SCRATCH_SIZE];

CBUFFER_START(SortConstants)
uint elementCount;
CBUFFER_END

uint GetLDSIndex(uint index)
{
#if LDS_PADDING_PERIOD
	return index + index / LDS_PADDING_PERIOD;
#else
	return index;
#endif
}

void LoadFromMemory(uint ldsIndex,uint memIndex,uint size)
{
	[unroll]
	for (uint i = 0; i < size; ++i)
	{
		KVP kvp = { MAX_FLOAT, 0 }; // MAX_FLOAT
		if (memIndex + i < elementCount)
			kvp = inputSequence[memIndex + i];

		uint paddedLdsIndex = GetLDSIndex(ldsIndex + i);
		scratch[paddedLdsIndex] = kvp.key;
		scratch[paddedLdsIndex + LDS_VALUES_OFFSET] = asfloat(kvp.value);
	}
}

void StoreToMemory(uint memIndex, uint ldsIndex,uint size)
{
	[unroll]
	for (uint i = 0; i < size; ++i)
		if (memIndex + i < elementCount)
		{
			uint paddedLdsIndex = GetLDSIndex(ldsIndex + i);
			uint value = asuint(scratch[paddedLdsIndex + LDS_VALUES_OFFSET]);
#if FINAL_PASS
			sortedSequence[memIndex + i] = value;
#else
			float key = scratch[paddedLdsIndex];
			KVP kvp = { key, value };
			sortedSequence[memIndex + i] = kvp;
#endif
		}
}

// Bitonic sort on small chunks of kvp of size ELEMENTS_COUNT - execute in O(log²(ELEMENTS_COUNT))
[numthreads(BITONIC_THREADS_COUNT,1,1)]
void BitonicSort(uint id : SV_GroupIndex, uint3 groupId : SV_GroupId)
{
	// Skip useless groups
	if (groupId.x > elementCount / ELEMENTS_COUNT)
		return;

	// Load data from memory to LDS
	//[unroll]
	for (uint i = 0; i < ITERATIONS_COUNT; ++i)
	{
		uint ldsIndex = ITERATION_INDEX(id,i);
		uint memIndex = DST_INDEX(groupId.x, ldsIndex);
		LoadFromMemory(ldsIndex * 2, memIndex * 2,2);
	}

	GroupMemoryBarrierWithGroupSync(); // LDS Writes visible

	for (uint step = 1; step < ELEMENTS_COUNT; step <<= 1) // O(log(ELEMENTS_COUNT))
		for (uint subStep = step; subStep != 0; subStep >>= 1) // O(log(step))
		{
			[unroll]
			for (uint i = 0; i < ITERATIONS_COUNT; ++i)
			{
				uint index = ITERATION_INDEX(id,i);
				uint lsb = index & (subStep - 1);
				uint index0 = (2 * index) - lsb;
				uint index1 = index0 + subStep;
#if USE_ALTERNATE_BITONIC_NETWORK
				if (subStep == step)
					index1 += step - (2 * lsb) - 1;
#endif

				uint ldsIndex0 = GetLDSIndex(index0);
				uint ldsIndex1 = GetLDSIndex(index1);

				float key0 = scratch[ldsIndex0];
				float key1 = scratch[ldsIndex1];

#if USE_ALTERNATE_BITONIC_NETWORK
				bool reverse = false;
#else
				bool reverse = index & step;
#endif
				if ((key0 > key1) != reverse)
				{
					// swap keys
					scratch[ldsIndex0] = key1;
					scratch[ldsIndex1] = key0;

					// swap values
					float value0 = scratch[ldsIndex0 + LDS_VALUES_OFFSET];
					scratch[ldsIndex0 + LDS_VALUES_OFFSET] = scratch[ldsIndex1 + LDS_VALUES_OFFSET];
					scratch[ldsIndex1 + LDS_VALUES_OFFSET] = value0;
				}
			}

			GroupMemoryBarrierWithGroupSync(); // LDS Writes visible
		}

	// Store sorted data from LDS to memory
	//[unroll]
	for (uint j = 0; j < ITERATIONS_COUNT; ++j) // "j" just to avoid warning with loop unrolling
	{
		uint ldsIndex = ITERATION_INDEX(id,j);
		uint memIndex = DST_INDEX(groupId.x, ldsIndex);
		StoreToMemory(memIndex * 2, ldsIndex * 2, 2);
	}
}

// Valid in bitonic kernel only
#undef ITERATION_INDEX
#undef DST_INDEX

// Merge sort on small chunks of kvp of size ELEMENTS_COUNT - execute in O(log²(ELEMENTS_COUNT))
//[numthreads(MERGE_THREADS_COUNT, 1, 1)]
//void MergeSort(uint id : SV_GroupIndex, uint3 groupId : SV_GroupId)
//{
//	// remove out of bounds threads
//	if (groupId.x > elementCount / ELEMENTS_COUNT)
//		return;
//
//	// Load data from memory to LDS
//	LoadFromMemory(id, groupId.x * MERGE_THREADS_COUNT + id, 1);
//	GroupMemoryBarrierWithGroupSync();
//
//	// O(log(ELEMENTS_COUNT))
//	for (int subArraySize = 1; subArraySize < ELEMENTS_COUNT; subArraySize <<= 1)
//	{
//		const int arraySize = subArraySize << 1;
//		const int lastIndex = subArraySize - 1;
//		const int arrayStart = arraySize * (id / arraySize);
//		const int arrayIndex = id - arrayStart;
//
//		// determine initial frame of the window
//		int2 window = uint2(max(0, arrayIndex - subArraySize), min(arrayIndex, lastIndex));
//
//		int index0, index1;
//		float key0, key1;
//
//		//uint nbIter = 0;
//		bool reverse = false;
//
//		// Binary search - O(log(subArraySize))
//		do
//		{
//			int windowIndex = (window.x + window.y + 1) >> 1;
//			int i0 = min(lastIndex,windowIndex);
//			int i1 = min(lastIndex, arrayIndex - windowIndex);
//
//			index0 = i0 + arrayStart;
//			index1 = i1 + arrayStart + subArraySize;
//
//			key0 = scratch[GetLDSIndex(index0)];
//			key1 = scratch[GetLDSIndex(index1)];
//
//			if (i0 + i1 == arrayIndex)
//			{
//				if (i0 > 0  && scratch[GetLDSIndex(max(0, index0 - 1))] > key1)
//					window.y = windowIndex - 1; // move window left
//				else if (i1 > 0 && scratch[GetLDSIndex(max(0, index1 - 1))] > key0)
//					window.x = windowIndex + (windowIndex == lastIndex ? 2 : 1); // move window right (Special handling at the right bound so that i1 can go down to 0)
//				else
//					break; // We're done;
//			}
//			else // special case handling
//			{
//				reverse = true;
//				break;
//			}
//		} 
//		while (true);
//
//		// Select left or right: Must handle special case for equality
//		bool select0 = /*(key0 == key1 && (id & 1)) || */((key0 < key1) != reverse);
//		
//		// Store selected key/value in register
//		float key = select0 ? key0 : key1;
//		float value = scratch[GetLDSIndex(select0 ? index0 : index1) + LDS_VALUES_OFFSET];
//
//		GroupMemoryBarrierWithGroupSync(); // Wait for all LDS reads to finish
//
//		// Update LDS
//		scratch[GetLDSIndex(id)] = key;
//		scratch[GetLDSIndex(id) + LDS_VALUES_OFFSET] = value;
//
//		GroupMemoryBarrierWithGroupSync(); // LDS Writes visible
//	}
//
//	StoreToMemory(groupId.x * MERGE_THREADS_COUNT + id, id, 1);
//}

CBUFFER_START(MergePassConstants)
uint subArraySize;
CBUFFER_END

float GetKeyWithCheck(uint index)
{
	if (index >= elementCount) // TODO Handle elementCount more efficiently
		return MAX_FLOAT;

	return inputSequence[index].key;
}

[numthreads(256, 1, 1)]
void MergePass(uint id : SV_DispatchThreadId,uint3 groupId : SV_GroupId)
{
	if (id.x >= elementCount)
		return;

	const int arraySize = subArraySize << 1;
	const int lastIndex = subArraySize - 1;
	const int arrayStart = arraySize * (id.x / arraySize);
	const int arrayIndex = id.x - arrayStart;

	// If the current array considered is then than one half filled (due to element count), we can copy it directly as it is already sorted
	if (elementCount - (uint)arrayStart < subArraySize)
	{
#if FINAL_PASS
		sortedSequence[id.x] = inputSequence[id.x].value;
#else
		sortedSequence[id.x] = inputSequence[id.x];
#endif
		return;
	}

	// determine initial frame of the window
	int2 window = uint2(max(0, arrayIndex - (int)subArraySize), min(arrayIndex, lastIndex));

	int index0, index1;
	float key0, key1;

	//uint nbIter = 0;
	bool reverse = false;

	// Binary search - O(log(subArraySize))
	do
	{
		int windowIndex = (window.x + window.y + 1) >> 1;
		int i0 = min(lastIndex, windowIndex);
		int i1 = min(lastIndex, arrayIndex - windowIndex);

		index0 = i0 + arrayStart;
		index1 = i1 + arrayStart + subArraySize;

		key0 = inputSequence[index0].key;
		key1 = GetKeyWithCheck(index1);

		if (i0 + i1 == arrayIndex)
		{
			if (i0 > 0 && inputSequence[max(0, index0 - 1)].key > key1)
				window.y = windowIndex - 1; // move window left
			else if (i1 > 0 && GetKeyWithCheck(max(0, index1 - 1)) > key0)
				window.x = windowIndex + (windowIndex == lastIndex ? 2 : 1); // move window right (Special handling at the right bound so that i1 can go down to 0)
			else
				break; // We're done;
		}
		else // special case handling
		{
			reverse = true;
			break;
		}
	} while (true);

	// Select left or right: Must handle special case for equality
	bool select0 = (key0 == key1 && (id & 1)) || ((key0 < key1) != reverse);
	uint value = inputSequence[(select0 ? index0 : index1)].value;

#if FINAL_PASS
	sortedSequence[id.x] = value;
#else
	float key = select0 ? key0 : key1;
	KVP kvp = { key, value };
	sortedSequence[id.x] = kvp;
#endif

}