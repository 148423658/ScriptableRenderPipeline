#pragma kernel CSMain
${VFXGlobalInclude}

#ifndef HAS_KILL
#define HAS_KILL 0
#endif

${VFXCBuffer}
${VFXGeneratedBlockFunction}

RWStructuredBuffer<int> flags;
AppendStructuredBuffer<uint> deadListOut;

groupshared uint3 boundsLDS[2];
RWStructuredBuffer<uint3> bounds;

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupThreadID)
{
	if (groupId.x == 0)
	{
		boundsLDS[0] = (uint3)0xFFFFFFFF;
		boundsLDS[1] = (uint3)0;
	}
	GroupMemoryBarrierWithGroupSync();
	
	uint nbMax = 2048; //TEMP

#if HAS_KILL
	if (id.x < nbMax && && flags[id.x] == 1)
	{
		bool kill = false;
		${VFXComputeParameters}
		${VFXProcessBlock}
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			${WriteAttribute}
			
			uint3 sortablePos = ConvertFloatToSortableUint(${Attribute_Current_position});
			
			InterlockedMin(boundsLDS[0].x,sortablePos.x);
			InterlockedMin(boundsLDS[0].y,sortablePos.y);
			InterlockedMin(boundsLDS[0].z,sortablePos.z);
			
			InterlockedMax(boundsLDS[1].x,sortablePos.x);
			InterlockedMax(boundsLDS[1].y,sortablePos.y);
			InterlockedMax(boundsLDS[1].z,sortablePos.z);
		}
	}
#else
	if (id.x < nbMax)
	{
		${VFXComputeParameters}
		${VFXProcessBlock}
		${WriteAttribute}
	}
#endif

	GroupMemoryBarrierWithGroupSync();
	if (groupId.x == 0)
	{
		InterlockedMin(bounds[0].x,boundsLDS[0].x);
		InterlockedMin(bounds[0].y,boundsLDS[0].y);
		InterlockedMin(bounds[0].z,boundsLDS[0].z);
		
		InterlockedMax(bounds[1].x,boundsLDS[1].x);
		InterlockedMax(bounds[1].y,boundsLDS[1].y);
		InterlockedMax(bounds[1].z,boundsLDS[1].z);
	}
}