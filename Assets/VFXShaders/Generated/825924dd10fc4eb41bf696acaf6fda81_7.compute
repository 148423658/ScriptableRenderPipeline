#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "../VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 256

CBUFFER_START(initUniforms)
	float3 initUniform0_kVFXCombine3fOp;
	float initUniform3_kVFXValueOp;
	
	float3 initUniform1_kVFXCombine3fOp;
	uint nbSpawned;
	
	float3 initUniform2_kVFXCombine3fOp;
	uint spawnIndex;
	
CBUFFER_END

CBUFFER_START(updateUniforms)
	float updateUniform0_kVFXDeltaTimeOp;
	uint nbMax;
	uint2 updateUniforms_PADDING_0;

CBUFFER_END

struct Attribute0
{
	float3 position;
	float lifetime;
};

struct Attribute1
{
	float age;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
StructuredBuffer<Attribute0> attribBuffer0_RO;
RWStructuredBuffer<Attribute1> attribBuffer1;

RWStructuredBuffer<int> flags;
ConsumeStructuredBuffer<uint> deadListIn;
AppendStructuredBuffer<uint> deadListOut;
Buffer<uint> deadListCount; // This is bad to use a SRV to fetch deadList count but Unity API currently prevent from copying to CB

#if USE_DYNAMIC_AABB
RWStructuredBuffer<uint3> bounds;
#endif

#if USE_DYNAMIC_AABB
groupshared uint3 boundsLDS[2];

#endif
void VFXBlockPositionAABBSequence( inout float3 position,uint particleId,float3 Box_center,float3 Box_size,float3 Number)
{
	float3 nPos;
	nPos.x = fmod(particleId,Number.x);
	nPos.y = fmod((int)(particleId / Number.x),Number.y);
	nPos.z = fmod((int)(particleId / (Number.x * Number.y)),Number.z);
	nPos = nPos / Number - 0.5f;
	position = nPos * Box_size + Box_center;
}

void VFXBlockSetLifetimeConstant( inout float lifetime,float Lifetime)
{
	lifetime = max(Lifetime,0.0f);
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < min(nbSpawned,deadListCount[0]))
	{
		uint index = deadListIn.Consume();
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		
		uint local_particleId = (uint)0;
		
		
		local_particleId = spawnIndex + id.x;
		VFXBlockPositionAABBSequence( attrib0.position,local_particleId,initUniform0_kVFXCombine3fOp,initUniform1_kVFXCombine3fOp,initUniform2_kVFXCombine3fOp);
		VFXBlockSetLifetimeConstant( attrib0.lifetime,initUniform3_kVFXValueOp);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		
		flags[index] = 1;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	#if USE_DYNAMIC_AABB
	if (groupId.x == 0)
	{
		boundsLDS[0] = (uint3)0xFFFFFFFF;
		boundsLDS[1] = (uint3)0;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	#endif
	if (id.x < nbMax && flags[id.x] == 1)
	{
		uint index = id.x;
		bool kill = false;
		
		Attribute0 attrib0 = attribBuffer0_RO[index];
		Attribute1 attrib1 = attribBuffer1[index];
		
		
		
		attrib1.age += updateUniform0_kVFXDeltaTimeOp;
		if (attrib1.age >= attrib0.lifetime)
			kill = true;
		
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			attribBuffer1[index] = attrib1;
			#if USE_DYNAMIC_AABB
			
			uint3 sortablePos = ConvertFloatToSortableUint(attrib0.position);
			
			InterlockedMin(boundsLDS[0].x,sortablePos.x);
			InterlockedMin(boundsLDS[0].y,sortablePos.y);
			InterlockedMin(boundsLDS[0].z,sortablePos.z);
			
			InterlockedMax(boundsLDS[1].x,sortablePos.x);
			InterlockedMax(boundsLDS[1].y,sortablePos.y);
			InterlockedMax(boundsLDS[1].z,sortablePos.z);
			#endif
		}
	}
	#if USE_DYNAMIC_AABB
	
	GroupMemoryBarrierWithGroupSync();
	
	if (groupId.x == 0)
	{
		InterlockedMin(bounds[0].x,boundsLDS[0].x);
		InterlockedMin(bounds[0].y,boundsLDS[0].y);
		InterlockedMin(bounds[0].z,boundsLDS[0].z);
		
		InterlockedMax(bounds[1].x,boundsLDS[1].x);
		InterlockedMax(bounds[1].y,boundsLDS[1].y);
		InterlockedMax(bounds[1].z,boundsLDS[1].z);
	}
	#endif
}

