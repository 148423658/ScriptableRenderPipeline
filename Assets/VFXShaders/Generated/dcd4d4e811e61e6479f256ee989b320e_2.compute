#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "../VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 100

CBUFFER_START(initUniforms)
	float3 initUniform0_kVFXCombine3fOp;
	float initUniform1_kVFXValueOp;
	
	uint nbSpawned;
	uint spawnIndex;
	uint2 initUniforms_PADDING_0;

CBUFFER_END

CBUFFER_START(updateUniforms)
	float updateUniform0_kVFXValueOp;
	float updateUniform1_kVFXDeltaTimeOp;
	uint nbMax;
	uint updateUniforms_PADDING_0;

CBUFFER_END

struct Attribute0
{
	float3 position;
	uint _PADDING_0;
};

struct Attribute1
{
	float2 size;
};

struct Attribute2
{
	float texIndex;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
StructuredBuffer<Attribute0> attribBuffer0_RO;
RWStructuredBuffer<Attribute1> attribBuffer1;
RWStructuredBuffer<Attribute2> attribBuffer2;

#if USE_DYNAMIC_AABB
RWStructuredBuffer<uint3> bounds;
#endif

#if USE_DYNAMIC_AABB
groupshared uint3 boundsLDS[2];

#endif
void VFXBlockSetPositionPoint( inout float3 position,float3 pos)
{
	position = pos;
}

void VFXBlockSizeConstantSquare( inout float2 size,float Size)
{
	size = float2(Size,Size);
}

void VFXBlockSubUVAnimateConstantRate( inout float texIndex,float Framerate,float deltaTime)
{
	texIndex += Framerate * deltaTime;
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < nbSpawned)
	{
		uint index = id.x + spawnIndex;
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		Attribute2 attrib2 = (Attribute2)0;
		
		
		VFXBlockSetPositionPoint( attrib0.position,initUniform0_kVFXCombine3fOp);
		VFXBlockSizeConstantSquare( attrib1.size,initUniform1_kVFXValueOp);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		attribBuffer2[index] = attrib2;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	#if USE_DYNAMIC_AABB
	if (groupId.x == 0)
	{
		boundsLDS[0] = (uint3)0xFFFFFFFF;
		boundsLDS[1] = (uint3)0;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	#endif
	if (id.x < nbMax)
	{
		uint index = id.x;
		
		Attribute0 attrib0 = attribBuffer0_RO[index];
		Attribute2 attrib2 = attribBuffer2[index];
		
		
		VFXBlockSubUVAnimateConstantRate( attrib2.texIndex,updateUniform0_kVFXValueOp,updateUniform1_kVFXDeltaTimeOp);
		
		attribBuffer2[index] = attrib2;
		#if USE_DYNAMIC_AABB
		
		uint3 sortablePos = ConvertFloatToSortableUint(attrib0.position);
		
		InterlockedMin(boundsLDS[0].x,sortablePos.x);
		InterlockedMin(boundsLDS[0].y,sortablePos.y);
		InterlockedMin(boundsLDS[0].z,sortablePos.z);
		
		InterlockedMax(boundsLDS[1].x,sortablePos.x);
		InterlockedMax(boundsLDS[1].y,sortablePos.y);
		InterlockedMax(boundsLDS[1].z,sortablePos.z);
		#endif
	}
	#if USE_DYNAMIC_AABB
	
	GroupMemoryBarrierWithGroupSync();
	
	if (groupId.x == 0)
	{
		InterlockedMin(bounds[0].x,boundsLDS[0].x);
		InterlockedMin(bounds[0].y,boundsLDS[0].y);
		InterlockedMin(bounds[0].z,boundsLDS[0].z);
		
		InterlockedMax(bounds[1].x,boundsLDS[1].x);
		InterlockedMax(bounds[1].y,boundsLDS[1].y);
		InterlockedMax(bounds[1].z,boundsLDS[1].z);
	}
	#endif
}

