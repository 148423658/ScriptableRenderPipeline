#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "../VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 256

CBUFFER_START(initUniforms)
	float2 initUniform0_kVFXValueOp;
	float initUniform1_kVFXValueOp;
	float initUniform2_kVFXValueOp;
	
	float initUniform3_kVFXValueOp;
	float initUniform4_kVFXValueOp;
	float initUniform5_kVFXValueOp;
	float initUniform6_kVFXValueOp;
	
	float initUniform7_kVFXValueOp;
	uint initUniform8_kVFXSystemSeedOp;
	uint nbSpawned;
	uint spawnIndex;
	
CBUFFER_END

CBUFFER_START(updateUniforms)
	float4x4 updateUniform0_kVFXTRSToMatrixOp;
	
	float4x4 updateUniform3_kVFXInverseTRSOp;
	
	float updateUniform1_kVFXValueOp;
	float updateUniform2_kVFXValueOp;
	float updateUniform4_kVFXDeltaTimeOp;
	uint nbMax;
	
CBUFFER_END

Texture3D updateSampler0_kVFXValueOpTexture;
SamplerState samplerupdateSampler0_kVFXValueOpTexture;

Texture2D floatTexture;
SamplerState samplerfloatTexture;

struct Attribute0
{
	float3 position;
	float age;
};

struct Attribute1
{
	float3 velocity;
	float lifetime;
};

struct Attribute2
{
	float3 up;
	float texIndex;
};

struct Attribute3
{
	float3 side;
	uint _PADDING_0;
};

struct Attribute4
{
	float3 front;
	uint _PADDING_0;
};

struct Attribute6
{
	float2 size;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
RWStructuredBuffer<Attribute1> attribBuffer1;
RWStructuredBuffer<Attribute2> attribBuffer2;
StructuredBuffer<Attribute2> attribBuffer2_RO;
RWStructuredBuffer<Attribute3> attribBuffer3;
StructuredBuffer<Attribute3> attribBuffer3_RO;
RWStructuredBuffer<Attribute4> attribBuffer4;
StructuredBuffer<Attribute4> attribBuffer4_RO;
RWStructuredBuffer<Attribute6> attribBuffer6;
StructuredBuffer<Attribute6> attribBuffer6_RO;

struct OutputData
{
	float3 position;
	float age;
	float3 velocity;
	float lifetime;
	float3 up;
	float texIndex;
	float3 side;
	uint _PADDING_0;
	float3 front;
	uint _PADDING_1;
	float2 size;
	uint2 _PADDING_2;
};

AppendStructuredBuffer<OutputData> outputBuffer;

RWStructuredBuffer<int> flags;
ConsumeStructuredBuffer<uint> deadListIn;
AppendStructuredBuffer<uint> deadListOut;
Buffer<uint> deadListCount; // This is bad to use a SRV to fetch deadList count but Unity API currently prevent from copying to CB

RWStructuredBuffer<uint3> bounds;

float rand(inout uint seed)
{
	seed = 1664525 * seed + 1013904223;
	return float(seed) / 4294967296.0;
}

float4 sampleSignal(float v,float u) // sample gradient
{
	return floatTexture.SampleLevel(samplerfloatTexture,float2(((0.9921875 * saturate(u)) + 0.00390625),v),0);
}

// Non optimized generic function to allow curve edition without recompiling
float sampleSignal(float4 curveData,float u) // sample curve
{
	float uNorm = (u * curveData.x) + curveData.y;
	switch(asuint(curveData.w) >> 2)
	{
		case 1: uNorm = ((0.9921875 * frac(min(1.0f - 1e-5f,uNorm))) + 0.00390625); break; // clamp end
		case 2: uNorm = ((0.9921875 * frac(max(0.0f,uNorm))) + 0.00390625); break; // clamp start
		case 3: uNorm = ((0.9921875 * saturate(uNorm)) + 0.00390625); break; // clamp both
	}
	return floatTexture.SampleLevel(samplerfloatTexture,float2(uNorm,curveData.z),0)[asuint(curveData.w) & 0x3];
}

float3 sampleSpline(float v,float u)
{
	return floatTexture.SampleLevel(samplerfloatTexture,float2(((0.9921875 * saturate(u)) + 0.00390625),v),0);
}

groupshared uint3 boundsLDS[2];

void VFXBlockPositionSpline( inout float3 position,inout float3 velocity,inout float3 front,inout float3 side,inout float3 up,float2 Spline,float radius,inout uint seed)
{
	float t = RAND;
	float3 center = SAMPLE_SPLINE_POSITION(Spline,t);
	float3 tangent = normalize(SAMPLE_SPLINE_TANGENT(Spline,t));
	up = tangent;
	position = PositionOnCylinderSurface(center,tangent,0.0f,radius,0.0f,RAND * UNITY_TWO_PI);
	front = normalize(position - center);
	side = cross(front,up);
	velocity += tangent * RAND;
}

void VFXBlockSetLifetimeRandom( inout float lifetime,float MinLifetime,float MaxLifetime,inout uint seed)
{
	lifetime = max(MinLifetime + RAND * (MaxLifetime-MinLifetime),0.0f);
}

void VFXBlockSetSubUVRandom( inout float texIndex,float MinIndex,float MaxIndex,inout uint seed)
{
	texIndex = lerp(MinIndex,MaxIndex,RAND);
}

void VFXBlockSizeRandomSquare( inout float2 size,float MinSize,float MaxSize,inout uint seed)
{
	float s = lerp(MinSize,MaxSize,RAND);
	size = float2(s,s);
}

void VFXBlockVectorFieldRelativeForce( inout float3 velocity,float3 position,VFXSampler3D VectorField,float4x4 Box,float4x4 InvBox,float Intensity,float DragCoefficient,float deltaTime)
{
	float3 vectorFieldCoord = mul(INVERSE(Box), float4(position,1.0f)).xyz;
	float3 value = SampleTexture(VectorField, vectorFieldCoord + 0.5f).xyz * 2.0f - 1.0f;
	value = mul(Box,float4(value,0.0f)).xyz * Intensity;
	float3 relativeForce = value - velocity;
	velocity += relativeForce * min(1.0,(DragCoefficient * deltaTime));
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < min(nbSpawned,deadListCount[0]))
	{
		uint index = deadListIn.Consume();
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		Attribute2 attrib2 = (Attribute2)0;
		Attribute3 attrib3 = (Attribute3)0;
		Attribute4 attrib4 = (Attribute4)0;
		Attribute6 attrib6 = (Attribute6)0;
		
		uint local_seed = (uint)0;
		
		
		uint seed = (id.x + spawnIndex) ^ initUniform8_kVFXSystemSeedOp;
		seed = (seed ^ 61) ^ (seed >> 16);
		seed *= 9;
		seed = seed ^ (seed >> 4);
		seed *= 0x27d4eb2d;
		seed = seed ^ (seed >> 15);
		local_seed = seed;
		
		VFXBlockPositionSpline( attrib0.position,attrib1.velocity,attrib4.front,attrib3.side,attrib2.up,initUniform0_kVFXValueOp,initUniform1_kVFXValueOp,local_seed);
		VFXBlockSetLifetimeRandom( attrib1.lifetime,initUniform2_kVFXValueOp,initUniform3_kVFXValueOp,local_seed);
		VFXBlockSetSubUVRandom( attrib2.texIndex,initUniform4_kVFXValueOp,initUniform5_kVFXValueOp,local_seed);
		VFXBlockSizeRandomSquare( attrib6.size,initUniform6_kVFXValueOp,initUniform7_kVFXValueOp,local_seed);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		attribBuffer2[index] = attrib2;
		attribBuffer3[index] = attrib3;
		attribBuffer4[index] = attrib4;
		attribBuffer6[index] = attrib6;
		
		flags[index] = 1;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (groupId.x == 0)
	{
		boundsLDS[0] = (uint3)0xFFFFFFFF;
		boundsLDS[1] = (uint3)0;
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	if (id.x < nbMax && flags[id.x] == 1)
	{
		uint index = id.x;
		bool kill = false;
		
		Attribute0 attrib0 = attribBuffer0[index];
		Attribute1 attrib1 = attribBuffer1[index];
		Attribute2 attrib2 = attribBuffer2_RO[index];
		Attribute3 attrib3 = attribBuffer3_RO[index];
		Attribute4 attrib4 = attribBuffer4_RO[index];
		Attribute6 attrib6 = attribBuffer6_RO[index];
		
		VFXSampler3D updateSampler0_kVFXValueOp = InitSampler(updateSampler0_kVFXValueOpTexture,samplerupdateSampler0_kVFXValueOpTexture);
		
		VFXBlockVectorFieldRelativeForce( attrib1.velocity,attrib0.position,updateSampler0_kVFXValueOp,updateUniform0_kVFXTRSToMatrixOp,updateUniform3_kVFXInverseTRSOp,updateUniform1_kVFXValueOp,updateUniform2_kVFXValueOp,updateUniform4_kVFXDeltaTimeOp);
		
		attrib0.position += attrib1.velocity * updateUniform4_kVFXDeltaTimeOp;
		
		attrib0.age += updateUniform4_kVFXDeltaTimeOp;
		if (attrib0.age >= attrib1.lifetime)
			kill = true;
		
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			attribBuffer0[index] = attrib0;
			attribBuffer1[index] = attrib1;
			
			OutputData outputData = (OutputData)0;
			outputData.position = attrib0.position;
			outputData.age = attrib0.age;
			outputData.velocity = attrib1.velocity;
			outputData.lifetime = attrib1.lifetime;
			outputData.up = attrib2.up;
			outputData.texIndex = attrib2.texIndex;
			outputData.side = attrib3.side;
			outputData.front = attrib4.front;
			outputData.size = attrib6.size;
			outputBuffer.Append(outputData);
			
			uint3 sortablePos = ConvertFloatToSortableUint(attrib0.position);
			
			InterlockedMin(boundsLDS[0].x,sortablePos.x);
			InterlockedMin(boundsLDS[0].y,sortablePos.y);
			InterlockedMin(boundsLDS[0].z,sortablePos.z);
			
			InterlockedMax(boundsLDS[1].x,sortablePos.x);
			InterlockedMax(boundsLDS[1].y,sortablePos.y);
			InterlockedMax(boundsLDS[1].z,sortablePos.z);
		}
	}
	
	GroupMemoryBarrierWithGroupSync();
	
	if (groupId.x == 0)
	{
		InterlockedMin(bounds[0].x,boundsLDS[0].x);
		InterlockedMin(bounds[0].y,boundsLDS[0].y);
		InterlockedMin(bounds[0].z,boundsLDS[0].z);
		
		InterlockedMax(bounds[1].x,boundsLDS[1].x);
		InterlockedMax(bounds[1].y,boundsLDS[1].y);
		InterlockedMax(bounds[1].z,boundsLDS[1].z);
	}
}

