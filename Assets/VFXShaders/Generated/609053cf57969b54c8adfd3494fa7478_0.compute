#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "../VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 100

CBUFFER_START(initUniforms)
	float3 initUniform2_kVFXCombine3fOp;
	float initUniform0_kVFXValueOp;
	
	float3 initUniform5_kVFXCombine3fOp;
	float initUniform1_kVFXValueOp;
	
	float initUniform3_kVFXValueOp;
	float initUniform4_kVFXValueOp;
	uint initUniform6_kVFXSystemSeedOp;
	uint nbSpawned;
	
	uint spawnIndex;
	uint3 initUniforms_PADDING_0;

CBUFFER_END

CBUFFER_START(updateUniforms)
	float updateUniform0_kVFXValueOp;
	float updateUniform1_kVFXDeltaTimeOp;
	uint nbMax;
	uint updateUniforms_PADDING_0;

CBUFFER_END

Texture2D floatTexture;
SamplerState samplerfloatTexture;

struct Attribute0
{
	float2 size;
};

struct Attribute1
{
	float3 velocity;
	float lifetime;
};

struct Attribute2
{
	float3 position;
	float alpha;
};

struct Attribute3
{
	float3 color;
	uint _PADDING_0;
};

struct Attribute4
{
	float age;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
RWStructuredBuffer<Attribute1> attribBuffer1;
StructuredBuffer<Attribute1> attribBuffer1_RO;
RWStructuredBuffer<Attribute2> attribBuffer2;
RWStructuredBuffer<Attribute3> attribBuffer3;
RWStructuredBuffer<Attribute4> attribBuffer4;

RWStructuredBuffer<int> flags;
ConsumeStructuredBuffer<uint> deadListIn;
AppendStructuredBuffer<uint> deadListOut;
Buffer<uint> deadListCount; // This is bad to use a SRV to fetch deadList count but Unity API currently prevent from copying to CB


float4 sampleSignal(float v,float u) // sample gradient
{
	return floatTexture.SampleLevel(samplerfloatTexture,float2(((0.9921875 * saturate(u)) + 0.00390625),v),0);
}

// Non optimized generic function to allow curve edition without recompiling
float sampleSignal(float4 curveData,float u) // sample curve
{
	float uNorm = (u * curveData.x) + curveData.y;
	switch(asuint(curveData.w) >> 2)
	{
		case 1: uNorm = ((0.9921875 * frac(min(1.0f - 1e-5f,uNorm))) + 0.00390625); break; // clamp end
		case 2: uNorm = ((0.9921875 * frac(max(0.0f,uNorm))) + 0.00390625); break; // clamp start
		case 3: uNorm = ((0.9921875 * saturate(uNorm)) + 0.00390625); break; // clamp both
	}
	return floatTexture.SampleLevel(samplerfloatTexture,float2(uNorm,curveData.z),0)[asuint(curveData.w) & 0x3];
}

float3 sampleSpline(float v,float u)
{
	return floatTexture.SampleLevel(samplerfloatTexture,float2(((0.9921875 * saturate(u)) + 0.00390625),v),0);
}

void VFXBlockSizeRandomSquare( inout float2 size,float MinSize,float MaxSize,inout uint seed)
{
	float s = lerp(MinSize,MaxSize,RAND);
	size = float2(s,s);
}

void VFXBlockVelocityConstant( inout float3 velocity,float3 Velocity)
{
	velocity += Velocity;
}

void VFXBlockSetLifetimeRandom( inout float lifetime,float MinLifetime,float MaxLifetime,inout uint seed)
{
	lifetime = max(MinLifetime + RAND * (MaxLifetime-MinLifetime),0.0f);
}

void VFXBlockVelocityRandomVector( inout float3 velocity,float3 Divergence,inout uint seed)
{
	velocity += (RAND3 * 2 - 1) * Divergence;
}

void VFXBlockSetColorGradientOverLifetime( inout float3 color,inout float alpha,float age,float lifetime,float Gradient)
{
	float ratio = saturate(age / lifetime);
	float4 rgba = SAMPLE(Gradient,ratio);
	color = rgba.rgb;
	alpha = rgba.a;
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < min(nbSpawned,deadListCount[0]))
	{
		uint index = deadListIn.Consume();
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		Attribute2 attrib2 = (Attribute2)0;
		Attribute3 attrib3 = (Attribute3)0;
		Attribute4 attrib4 = (Attribute4)0;
		
		uint local_seed = (uint)0;
		
		
		local_seed = WangHash((id.x + spawnIndex) ^ initUniform6_kVFXSystemSeedOp);
		VFXBlockSizeRandomSquare( attrib0.size,initUniform0_kVFXValueOp,initUniform1_kVFXValueOp,local_seed);
		VFXBlockVelocityConstant( attrib1.velocity,initUniform2_kVFXCombine3fOp);
		VFXBlockSetLifetimeRandom( attrib1.lifetime,initUniform3_kVFXValueOp,initUniform4_kVFXValueOp,local_seed);
		VFXBlockVelocityRandomVector( attrib1.velocity,initUniform5_kVFXCombine3fOp,local_seed);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		attribBuffer2[index] = attrib2;
		attribBuffer3[index] = attrib3;
		attribBuffer4[index] = attrib4;
		
		flags[index] = 1;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < nbMax && flags[id.x] == 1)
	{
		uint index = id.x;
		bool kill = false;
		
		Attribute1 attrib1 = attribBuffer1_RO[index];
		Attribute2 attrib2 = attribBuffer2[index];
		Attribute3 attrib3 = attribBuffer3[index];
		Attribute4 attrib4 = attribBuffer4[index];
		
		
		VFXBlockSetColorGradientOverLifetime( attrib3.color,attrib2.alpha,attrib4.age,attrib1.lifetime,updateUniform0_kVFXValueOp);
		
		attrib2.position += attrib1.velocity * updateUniform1_kVFXDeltaTimeOp;
		
		attrib4.age += updateUniform1_kVFXDeltaTimeOp;
		if (attrib4.age >= attrib1.lifetime)
			kill = true;
		
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			attribBuffer2[index] = attrib2;
			attribBuffer3[index] = attrib3;
			attribBuffer4[index] = attrib4;
		}
	}
}

