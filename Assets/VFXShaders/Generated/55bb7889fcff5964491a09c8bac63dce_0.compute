#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "..\VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 256

CBUFFER_START(GlobalInfo)
	float deltaTime;
	float totalTime;
	uint nbMax;
	uint systemSeed;
CBUFFER_END

CBUFFER_START(SpawnInfo)
	uint nbSpawned;
	uint spawnIndex;
CBUFFER_END

CBUFFER_START(GlobalUniforms)
	float3 globalUniform0;
	float globalUniform1;
CBUFFER_END

CBUFFER_START(initUniforms)
	float initUniform0;
CBUFFER_END

CBUFFER_START(updateUniforms)
	float4 updateUniform0;
	float updateUniform1;
	float4x4 updateUniform2;
	float updateUniform3;
	float updateUniform4;
	float updateUniform5;
	float updateUniform6;
	float updateUniform7;
	float updateUniform8;
	float updateUniform9;
	float4x4 updateUniform10;
CBUFFER_END

Texture3D updateSampler0Texture;
SamplerState samplerupdateSampler0Texture;

Texture2D curveTexture;
SamplerState samplercurveTexture;

struct Attribute0
{
	float lifetime;
};

struct Attribute1
{
	float3 position;
	float _PADDING_;
};

struct Attribute2
{
	float2 size;
};

struct Attribute3
{
	float3 velocity;
	float age;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
StructuredBuffer<Attribute0> attribBuffer0_RO;
RWStructuredBuffer<Attribute1> attribBuffer1;
RWStructuredBuffer<Attribute2> attribBuffer2;
RWStructuredBuffer<Attribute3> attribBuffer3;

RWStructuredBuffer<int> flags;
ConsumeStructuredBuffer<uint> deadListIn;
AppendStructuredBuffer<uint> deadListOut;
Buffer<uint> deadListCount; // This is bad to use a SRV to fetch deadList count but Unity API currently prevent from copying to CB

RWStructuredBuffer<uint3> bounds;

float rand(inout uint seed)
{
	seed = 1664525 * seed + 1013904223;
	return float(seed) / 4294967296.0;
}

// Non optimized generic function to allow curve edition without recompiling
float sampleSignal(float4 curveData,float u) // sample curve
{
	float uNorm = (u * curveData.x) + curveData.y;
	switch(asuint(curveData.w) >> 2)
	{
		case 1: uNorm = ((0.9921875 * frac(min(1.0f - 1e-5f,uNorm))) + 0.00390625); break; // clamp end
		case 2: uNorm = ((0.9921875 * frac(max(0.0f,uNorm))) + 0.00390625); break; // clamp start
		case 3: uNorm = ((0.9921875 * saturate(uNorm)) + 0.00390625); break; // clamp both
	}
	return curveTexture.SampleLevel(samplercurveTexture,float2(uNorm,curveData.z),0)[asuint(curveData.w) & 0x3];
}

void VFXBlockSetLifetimeConstant( inout float lifetime,float Lifetime)
{
	lifetime = max(Lifetime,0.0f);
}

void VFXBlockSetPositionSphereSurface( inout float3 position,float3 Sphere_center,float Sphere_radius,inout uint seed)
{
	float u1 = 2.0 * RAND - 1.0;
	float u2 = UNITY_TWO_PI * RAND;
	position = VFXPositionOnSphereSurface(Sphere,u1,u2);
}

void VFXBlockSizeOverLifeCurve( inout float2 size,float age,float lifetime,float4 Curve)
{
	float ratio = saturate(age/lifetime);
	float s = sampleSignal(Curve, ratio);
	size = float2(s,s);
}

void VFXBlockCollideWithSphere( inout float3 position,inout float3 velocity,float3 Sphere_center,float Sphere_radius,float Elasticity)
{
	float3 nextPos = position + velocity * deltaTime;
	float3 dir = Sphere_center - nextPos;
	float sqrLength = dot(dir,dir);
	if (sqrLength <= Sphere_radius * Sphere_radius)
	{	
		float dist = sqrt(sqrLength);
		float3 n = dir / dist;	
		float projVelocity = dot(n,velocity);
		
		if (projVelocity > 0)
			velocity -= ((1 + Elasticity) * projVelocity) * n;
			
		position += n * (dist - Sphere_radius);
	}
}

void VFXBlockVectorFieldRelativeForce( inout float3 velocity,float3 position,VFXSampler3D VectorField,float4x4 Box,float4x4 InvBox,float Intensity,float DragCoefficient)
{
	float3 vectorFieldCoord = mul(INVERSE(Box), float4(position,1.0f)).xyz;
	float3 value = SampleTexture(VectorField, vectorFieldCoord + 0.5f).xyz * 2.0f - 1.0f;
	value = mul(Box,float4(value,0.0f)).xyz * Intensity;
	float3 relativeForce = value - velocity;
	velocity += relativeForce * min(1.0,(DragCoefficient * deltaTime));
}

void VFXBlockSetForceConformToSphere( inout float3 velocity,float3 position,float3 Sphere_center,float Sphere_radius,float attractionSpeed,float attractionForce,float stickForce,float stickDistance)
{
	float3 dir = Sphere_center - position;
	float distToCenter = length(dir);
	float distToSurface = distToCenter - Sphere_radius;
	dir /= distToCenter;
	float spdNormal = dot(dir,velocity);
	float ratio = smoothstep(0.0,stickDistance * 2.0,abs(distToSurface));
	float tgtSpeed = sign(distToSurface) * attractionSpeed * ratio;
	float deltaSpeed = tgtSpeed - spdNormal;
	velocity += sign(deltaSpeed) * min(abs(deltaSpeed),deltaTime * lerp(stickForce,attractionForce,ratio)) * dir;
}

void VFXBlockSetForceLinearDrag( inout float3 velocity,float DragCoefficient)
{
	velocity *= max(0.0,(1.0 - DragCoefficient * deltaTime));
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < min(nbSpawned,deadListCount[0]))
	{
		uint index = deadListIn.Consume();
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		Attribute2 attrib2 = (Attribute2)0;
		Attribute3 attrib3 = (Attribute3)0;
		
		uint local_seed = (uint)0;
		
		
		uint seed = (id.x + spawnIndex) ^ systemSeed;
		seed = (seed ^ 61) ^ (seed >> 16);
		seed *= 9;
		seed = seed ^ (seed >> 4);
		seed *= 0x27d4eb2d;
		seed = seed ^ (seed >> 15);
		local_seed = seed;
		
		VFXBlockSetLifetimeConstant( attrib0.lifetime,initUniform0);
		VFXBlockSetPositionSphereSurface( attrib1.position,globalUniform0,globalUniform1,local_seed);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		attribBuffer2[index] = attrib2;
		attribBuffer3[index] = attrib3;
		
		flags[index] = 1;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < nbMax && flags[id.x] == 1)
	{
		uint index = id.x;
		bool kill = false;
		
		Attribute0 attrib0 = attribBuffer0_RO[index];
		Attribute1 attrib1 = attribBuffer1[index];
		Attribute2 attrib2 = attribBuffer2[index];
		Attribute3 attrib3 = attribBuffer3[index];
		
		VFXSampler3D updateSampler0 = InitSampler(updateSampler0Texture,samplerupdateSampler0Texture);
		
		VFXBlockSizeOverLifeCurve( attrib2.size,attrib3.age,attrib0.lifetime,updateUniform0);
		VFXBlockCollideWithSphere( attrib1.position,attrib3.velocity,globalUniform0,globalUniform1,updateUniform1);
		VFXBlockVectorFieldRelativeForce( attrib3.velocity,attrib1.position,updateSampler0,updateUniform2,updateUniform10,updateUniform3,updateUniform4);
		VFXBlockSetForceConformToSphere( attrib3.velocity,attrib1.position,globalUniform0,globalUniform1,updateUniform5,updateUniform6,updateUniform7,updateUniform8);
		VFXBlockSetForceLinearDrag( attrib3.velocity,updateUniform9);
		
		attrib1.position += attrib3.velocity * deltaTime;
		
		attrib3.age += deltaTime;
		if (attrib3.age >= attrib0.lifetime)
			kill = true;
		
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			attribBuffer1[index] = attrib1;
			attribBuffer2[index] = attrib2;
			attribBuffer3[index] = attrib3;
		}
	}
}

