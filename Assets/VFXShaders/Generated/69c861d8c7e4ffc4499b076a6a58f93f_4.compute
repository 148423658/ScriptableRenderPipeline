#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "../VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 256

CBUFFER_START(initUniforms)
	float3 initUniform0_kVFXCombine3fOp;
	float initUniform1_kVFXValueOp;
	
	float2 initUniform2_kVFXCombine2fOp;
	float initUniform3_kVFXValueOp;
	float initUniform4_kVFXValueOp;
	
	float initUniform5_kVFXValueOp;
	float initUniform6_kVFXValueOp;
	float initUniform7_kVFXValueOp;
	uint initUniform8_kVFXSystemSeedOp;
	
	uint nbSpawned;
	uint spawnIndex;
	uint2 initUniforms_PADDING_0;

CBUFFER_END

CBUFFER_START(updateUniforms)
	float3 updateUniform0_kVFXCombine3fOp;
	float updateUniform1_kVFXDeltaTimeOp;
	
	uint nbMax;
	uint3 updateUniforms_PADDING_0;

CBUFFER_END

struct Attribute0
{
	float3 position;
	float angle;
};

struct Attribute1
{
	float age;
};

struct Attribute2
{
	float3 velocity;
	uint _PADDING_0;
};

struct Attribute3
{
	float2 size;
};

struct Attribute4
{
	float lifetime;
};

struct Attribute5
{
	float angularVelocity;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
RWStructuredBuffer<Attribute1> attribBuffer1;
RWStructuredBuffer<Attribute2> attribBuffer2;
RWStructuredBuffer<Attribute3> attribBuffer3;
StructuredBuffer<Attribute3> attribBuffer3_RO;
RWStructuredBuffer<Attribute4> attribBuffer4;
StructuredBuffer<Attribute4> attribBuffer4_RO;
RWStructuredBuffer<Attribute5> attribBuffer5;
StructuredBuffer<Attribute5> attribBuffer5_RO;

struct OutputData
{
	float3 position;
	float angle;
	float2 size;
	float age;
	float lifetime;
};

AppendStructuredBuffer<OutputData> outputBuffer;

RWStructuredBuffer<int> flags;
ConsumeStructuredBuffer<uint> deadListIn;
AppendStructuredBuffer<uint> deadListOut;
Buffer<uint> deadListCount; // This is bad to use a SRV to fetch deadList count but Unity API currently prevent from copying to CB

RWStructuredBuffer<uint3> bounds;

float rand(inout uint seed)
{
	seed = 1664525 * seed + 1013904223;
	return float(seed) / 4294967296.0;
}

void VFXBlockSetPositionSphereSurface( inout float3 position,float3 Sphere_center,float Sphere_radius,uint systemSeed,uint seed)
{
	float u1 = 2.0 * RAND - 1.0;
	float u2 = UNITY_TWO_PI * RAND;
	position = VFXPositionOnSphereSurface(Sphere,u1,u2);
}

void VFXBlockVelocityRadialFromOrigin( float3 position,inout float3 velocity,float3 Origin,float2 MinMaxSpeed,uint systemSeed,uint seed)
{
	float3 dir = normalize(position - Origin);
	float speed = lerp(MinMaxSpeed.x,MinMaxSpeed.y,RAND);
	velocity += dir * speed;
}

void VFXBlockSizeRandomSquare( inout float2 size,float MinSize,float MaxSize,uint systemSeed,uint seed)
{
	float s = lerp(MinSize,MaxSize,RAND);
	size = float2(s,s);
}

void VFXBlockSetLifetimeConstant( inout float lifetime,float Lifetime)
{
	lifetime = max(Lifetime,0.0f);
}

void VFXBlockAngularVelocityRandom( inout float angularVelocity,float Min,float Max,uint systemSeed,uint seed)
{
	angularVelocity = lerp(Min,Max,RAND);
}

void VFXBlockSetForceConstant( inout float3 velocity,float3 Force,float deltaTime)
{
	velocity += Force * deltaTime;
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < min(nbSpawned,deadListCount[0]))
	{
		uint index = deadListIn.Consume();
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		Attribute2 attrib2 = (Attribute2)0;
		Attribute3 attrib3 = (Attribute3)0;
		Attribute4 attrib4 = (Attribute4)0;
		Attribute5 attrib5 = (Attribute5)0;
		
		uint local_seed = (uint)0;
		
		
		uint seed = (id.x + spawnIndex) ^ initUniform8_kVFXSystemSeedOp;
		seed = (seed ^ 61) ^ (seed >> 16);
		seed *= 9;
		seed = seed ^ (seed >> 4);
		seed *= 0x27d4eb2d;
		seed = seed ^ (seed >> 15);
		local_seed = seed;
		
		VFXBlockSetPositionSphereSurface( attrib0.position,initUniform0_kVFXCombine3fOp,initUniform1_kVFXValueOp,initUniform8_kVFXSystemSeedOp,local_seed);
		VFXBlockVelocityRadialFromOrigin( attrib0.position,attrib2.velocity,initUniform0_kVFXCombine3fOp,initUniform2_kVFXCombine2fOp,initUniform8_kVFXSystemSeedOp,local_seed);
		VFXBlockSizeRandomSquare( attrib3.size,initUniform3_kVFXValueOp,initUniform4_kVFXValueOp,initUniform8_kVFXSystemSeedOp,local_seed);
		VFXBlockSetLifetimeConstant( attrib4.lifetime,initUniform5_kVFXValueOp);
		VFXBlockAngularVelocityRandom( attrib5.angularVelocity,initUniform6_kVFXValueOp,initUniform7_kVFXValueOp,initUniform8_kVFXSystemSeedOp,local_seed);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		attribBuffer2[index] = attrib2;
		attribBuffer3[index] = attrib3;
		attribBuffer4[index] = attrib4;
		attribBuffer5[index] = attrib5;
		
		flags[index] = 1;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < nbMax && flags[id.x] == 1)
	{
		uint index = id.x;
		bool kill = false;
		
		Attribute0 attrib0 = attribBuffer0[index];
		Attribute1 attrib1 = attribBuffer1[index];
		Attribute2 attrib2 = attribBuffer2[index];
		Attribute3 attrib3 = attribBuffer3_RO[index];
		Attribute4 attrib4 = attribBuffer4_RO[index];
		Attribute5 attrib5 = attribBuffer5_RO[index];
		
		
		VFXBlockSetForceConstant( attrib2.velocity,updateUniform0_kVFXCombine3fOp,updateUniform1_kVFXDeltaTimeOp);
		
		attrib0.angle += attrib5.angularVelocity * updateUniform1_kVFXDeltaTimeOp;
		
		attrib0.position += attrib2.velocity * updateUniform1_kVFXDeltaTimeOp;
		
		attrib1.age += updateUniform1_kVFXDeltaTimeOp;
		if (attrib1.age >= attrib4.lifetime)
			kill = true;
		
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			attribBuffer0[index] = attrib0;
			attribBuffer1[index] = attrib1;
			attribBuffer2[index] = attrib2;
			
			OutputData outputData = (OutputData)0;
			outputData.position = attrib0.position;
			outputData.angle = attrib0.angle;
			outputData.size = attrib3.size;
			outputData.age = attrib1.age;
			outputData.lifetime = attrib4.lifetime;
			outputBuffer.Append(outputData);
		}
	}
}

