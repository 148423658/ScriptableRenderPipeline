#pragma kernel CSVFXInit
#pragma kernel CSVFXUpdate

#include "HLSLSupport.cginc"
#include "../VFXCommon.cginc"

#define NB_THREADS_PER_GROUP 256

CBUFFER_START(GlobalInfo)
	float deltaTime;
	float totalTime;
	uint nbMax;
	uint systemSeed;
CBUFFER_END

CBUFFER_START(SpawnInfo)
	uint nbSpawned;
	uint spawnIndex;
CBUFFER_END

CBUFFER_START(initUniforms)
	float3 initUniform0;
	float3 initUniform1;
	float2 initUniform2;
	float2 initUniform3;
	float initUniform4;
	float initUniform5;
	float initUniform6;
	float initUniform7;
	float initUniform8;
CBUFFER_END

CBUFFER_START(updateUniforms)
	float3 updateUniform0;
CBUFFER_END

Texture2D gradientTexture;
SamplerState samplergradientTexture;

struct Attribute0
{
	float3 velocity;
	float age;
};

struct Attribute1
{
	float3 position;
	uint _PADDING_1;
};

struct Attribute2
{
	float lifetime;
};

struct Attribute3
{
	float3 color;
	float texIndex;
};

struct Attribute4
{
	float alpha;
};

RWStructuredBuffer<Attribute0> attribBuffer0;
RWStructuredBuffer<Attribute1> attribBuffer1;
RWStructuredBuffer<Attribute2> attribBuffer2;
StructuredBuffer<Attribute2> attribBuffer2_RO;
RWStructuredBuffer<Attribute3> attribBuffer3;
RWStructuredBuffer<Attribute4> attribBuffer4;

RWStructuredBuffer<int> flags;
ConsumeStructuredBuffer<uint> deadListIn;
AppendStructuredBuffer<uint> deadListOut;
Buffer<uint> deadListCount; // This is bad to use a SRV to fetch deadList count but Unity API currently prevent from copying to CB

RWStructuredBuffer<uint3> bounds;

float rand(inout uint seed)
{
	seed = 1664525 * seed + 1013904223;
	return float(seed) / 4294967296.0;
}

float4 sampleSignal(float v,float u) // sample gradient
{
	return gradientTexture.SampleLevel(samplergradientTexture,float2(((0.9921875 * saturate(u)) + 0.00390625),v),0);
}

void VFXBlockSetPositionPoint( inout float3 position,float3 pos)
{
	position = pos;
}

void VFXBlockVelocityConstant( inout float3 velocity,float3 Velocity)
{
	velocity += Velocity;
}

void VFXBlockVelocityRadial( inout float3 velocity,float2 MinMaxAngle,float2 MinMaxSpeed,inout uint seed)
{
	float2 z = cos(radians(MinMaxAngle));
	float u1 = lerp(z.x,z.y,RAND);
	float u2 = UNITY_TWO_PI * RAND;
	float2 sincosTheta;
	sincos(u2,sincosTheta.x,sincosTheta.y);
	sincosTheta *= sqrt(1.0 - u1*u1);
	velocity += float3(sincosTheta,u1).xzy * lerp(MinMaxSpeed.x,MinMaxSpeed.y,RAND);
}

void VFXBlockSetLifetimeRandom( inout float lifetime,float MinLifetime,float MaxLifetime,inout uint seed)
{
	lifetime = max(MinLifetime + RAND * (MaxLifetime-MinLifetime),0.0f);
}

void VFXBlockSetSubUVRandom( inout float texIndex,float MinIndex,float MaxIndex,inout uint seed)
{
	texIndex = lerp(MinIndex,MaxIndex,RAND);
}

void VFXBlockSetColorRandomGradient( inout float3 color,inout float alpha,float Gradient,inout uint seed)
{
	float4 rgba = sampleSignal(Gradient,RAND);
	color = rgba.rgb;
	alpha = rgba.a;
}

void VFXBlockSetForceConstant( inout float3 velocity,float3 Force)
{
	velocity += Force * deltaTime;
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXInit(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < min(nbSpawned,deadListCount[0]))
	{
		uint index = deadListIn.Consume();
		
		Attribute0 attrib0 = (Attribute0)0;
		Attribute1 attrib1 = (Attribute1)0;
		Attribute2 attrib2 = (Attribute2)0;
		Attribute3 attrib3 = (Attribute3)0;
		Attribute4 attrib4 = (Attribute4)0;
		
		uint local_seed = (uint)0;
		
		
		uint seed = (id.x + spawnIndex) ^ systemSeed;
		seed = (seed ^ 61) ^ (seed >> 16);
		seed *= 9;
		seed = seed ^ (seed >> 4);
		seed *= 0x27d4eb2d;
		seed = seed ^ (seed >> 15);
		local_seed = seed;
		
		VFXBlockSetPositionPoint( attrib1.position,initUniform0);
		VFXBlockVelocityConstant( attrib0.velocity,initUniform1);
		VFXBlockVelocityRadial( attrib0.velocity,initUniform2,initUniform3,local_seed);
		VFXBlockSetLifetimeRandom( attrib2.lifetime,initUniform4,initUniform5,local_seed);
		VFXBlockSetSubUVRandom( attrib3.texIndex,initUniform6,initUniform7,local_seed);
		VFXBlockSetColorRandomGradient( attrib3.color,attrib4.alpha,initUniform8,local_seed);
		
		attribBuffer0[index] = attrib0;
		attribBuffer1[index] = attrib1;
		attribBuffer2[index] = attrib2;
		attribBuffer3[index] = attrib3;
		attribBuffer4[index] = attrib4;
		
		flags[index] = 1;
	}
}

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXUpdate(uint3 id : SV_DispatchThreadID,uint3 groupId : SV_GroupThreadID)
{
	if (id.x < nbMax && flags[id.x] == 1)
	{
		uint index = id.x;
		bool kill = false;
		
		Attribute0 attrib0 = attribBuffer0[index];
		Attribute1 attrib1 = attribBuffer1[index];
		Attribute2 attrib2 = attribBuffer2_RO[index];
		
		
		VFXBlockSetForceConstant( attrib0.velocity,updateUniform0);
		
		attrib1.position += attrib0.velocity * deltaTime;
		
		attrib0.age += deltaTime;
		if (attrib0.age >= attrib2.lifetime)
			kill = true;
		
		if (kill)
		{
			flags[index] = 0;
			deadListOut.Append(index);
		}
		else
		{
			attribBuffer0[index] = attrib0;
			attribBuffer1[index] = attrib1;
		}
	}
}

