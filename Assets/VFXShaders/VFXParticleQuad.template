Shader "Hidden/VFX/ParticleQuads"
{
	SubShader
	{
		${VFXShaderTags}
		
		Pass
		{
			${VFXOutputRenderState}
			Cull Off
				
			CGPROGRAM
				#pragma target 4.5
				#if !defined(VFX_WORLD_SPACE) && !defined(VFX_LOCAL_SPACE)
				#define VFX_LOCAL_SPACE 1
				#endif
				
				#include "UnityCG.cginc"
				${VFXGlobalInclude}
				${VFXGlobalDeclaration}
				${VFXGeneratedBlockFunction}
				
				#define VFX_NEEDS_COLOR_INTERPOLATOR (VFX_USE_COLOR_CURRENT || VFX_USE_ALPHA_CURRENT)
				
				ByteAddressBuffer attributeBuffer;
				
				float nbMax;
				
				#pragma vertex vert
				#pragma fragment frag
				
#if USE_SOFT_PARTICLE
				sampler2D_float _CameraDepthTexture;
#endif

#if USE_FLIPBOOK
				float2 GetSubUV(int flipBookIndex,float2 uv,float2 dim,float2 invDim)
				{
					float2 tile = float2(fmod(flipBookIndex,dim.x),dim.y - 1.0 - floor(flipBookIndex * invDim.x));
					return (tile + uv) * invDim;
				}
#endif
				
				struct ps_input
				{
					float4 pos : SV_POSITION;
#if VFX_NEEDS_COLOR_INTERPOLATOR
					nointerpolation float4 color : COLOR0;
#endif				
#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION
// x: inverse soft particles fade distance
// y: alpha threshold
// z: frame blending factor
					nointerpolation float3 builtInInterpolants : TEXCOORD0;
#endif
#if USE_SOFT_PARTICLE
					float4 projPos : TEXCOORD1;	
#endif
					float4 uv : TEXCOORD2;
				};
				
				struct ps_output
				{
					float4 color : SV_Target0;
				};
				
				ps_input vert(uint id : SV_VertexID, uint instanceID : SV_InstanceID)
				{
					uint index = (id >> 2) + instanceID * 2048;
					ps_input o = (ps_input)0;
					if (index < asuint(nbMax))
					{
						${VFXLoadAttributes:{alive}}
						if (alive)
						{
							${VFXLoadAttributes:{(?!(alive))(\b\w)}}
							${VFXProcessBlocks}
							
							o.uv.x = float(id & 1);
							o.uv.y = float((id & 2) >> 1);
							
							float2 offsets = size.xy * (o.uv - pivot.xy - 0.5f);
							float3x3 rot = GetRotationMatrix(front,radians(angle));
							
							position += mul(rot,side * offsets.x);
							position += mul(rot,up * offsets.y);
							position -= front * pivot.z;

							o.pos = mul(VFXModelViewProj(), float4(position,1.0f));

#if VFX_NEEDS_COLOR_INTERPOLATOR
							o.color = (float4)1.0f;
#if VFX_USE_COLOR_CURRENT
							o.color.rgb = color;
#endif
#if VFX_USE_ALPHA_CURRENT
							o.color.a = alpha;
#endif
#endif

#if USE_SOFT_PARTICLE				
							${VFXLoadParameter:{invSoftParticlesFadeDistance}}
							o.builtInInterpolants.x = invSoftParticlesFadeDistance;
							o.projPos = ComputeScreenPos(o.pos);
#endif
#if USE_ALPHA_TEST
							${VFXLoadParameter:{alphaThreshold}}
							o.builtInInterpolants.y = alphaThreshold;
#endif
#if USE_FLIPBOOK
							${VFXLoadParameter:{flipBookSize}}
							${VFXLoadParameter:{invFlipBookSize}}
							
							float frameBlend = frac(texIndex);
							float frameIndex = texIndex - frameBlend;
							
#if USE_FLIPBOOK_INTERPOLATION
							o.builtInInterpolants.z = frameBlend;
							o.uv.zw = GetSubUV(frameIndex + 1,o.uv.xy,flipBookSize,invFlipBookSize);
							
#endif
							o.uv.xy = GetSubUV(frameIndex,o.uv.xy,flipBookSize,invFlipBookSize);
#endif
						}
					}
					return o;
				}
				
				ps_output frag(ps_input i)
				{
					ps_output o = (ps_output)0;
					
					o.color = 1.0f;
#if VFX_NEEDS_COLOR_INTERPOLATOR
					o.color *= i.color;
#endif

					float4 texColor = texture_texture.Sample(samplertexture_texture,i.uv.xy);			
#if USE_FLIPBOOK_INTERPOLATION
					float4 texColor2 = texture_texture.Sample(samplertexture_texture,i.uv.zw);	
					texColor = lerp(texColor,texColor2,i.builtInInterpolants.z);
#endif
					o.color *= texColor;
					
#if USE_SOFT_PARTICLE
					float sceneZ = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos)));
					float fade = saturate(i.builtInInterpolants.x * (sceneZ - i.projPos.w));
					fade = fade * fade * (3.0 - (2.0 * fade)); // Smoothsteping the fade
					o.color.a *= fade;
#endif
#if USE_ALPHA_TEST
					clip(o.color.a - i.builtInInterpolants.y);
#endif

					return o;
				}
			ENDCG
		}
	}
	Fallback "Diffuse"
}
