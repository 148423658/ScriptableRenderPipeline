#pragma require geometry
#pragma vertex vert
#pragma geometry geom

uint vert(uint id : SV_VertexID) : TEXCOORD0
{
	return id;
}

[maxvertexcount(4)]
void geom(point uint intStream[1] : TEXCOORD0,inout TriangleStream<VFX_VARYING_PS_INPUTS> outStream)
{
	uint index = intStream[0];
	if (index < asuint(nbMax))
	{
		#if VFX_HAS_INDIRECT_DRAW
		index = indirectBuffer[index];
		#endif
		${VFXLoadAttributes:{alive}}
		if (alive)
		{
			${VFXLoadAttributes:{(?!(alive))(\b\w)}}
			${VFXProcessBlocks}
			
			if (!alive)
				return;
			
			#if USE_FLIPBOOK
			${VFXLoadParameter:{flipBookSize}}
			${VFXLoadParameter:{invFlipBookSize}}
			
			float frameBlend = frac(texIndex);
			float frameIndex = texIndex - frameBlend;
			#endif
			
			float3x3 rot = GetRotationMatrix(front,radians(angle));
			
			[unroll]
			for (int id = 0; id < 4; ++id)
			{
				VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
				
				o.VFX_VARYING_UV.x = float((id & 2) >> 1);
				o.VFX_VARYING_UV.y = float(id & 1);
				
				float3 vPos = position;
				vPos += TransformInElementSpace(float3(o.VFX_VARYING_UV.xy - 0.5f,0.0f),side,up,front,rot,pivot,float3(size,1.0f));
				
				o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);

				${VFXVertexCommonProcess}
				
				#if USE_FLIPBOOK			
				#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_FRAMEBLEND)
				o.VFX_VARYING_FRAMEBLEND = frameBlend;
				o.VFX_VARYING_UV.zw = GetSubUV(frameIndex + 1,o.VFX_VARYING_UV.xy,flipBookSize,invFlipBookSize);					
				#endif
				o.VFX_VARYING_UV.xy = GetSubUV(frameIndex,o.VFX_VARYING_UV.xy,flipBookSize,invFlipBookSize);
				#endif
				
				${VFXVertexAdditionalProcess}
				
				outStream.Append(o);
			}
		}
	}	
}
