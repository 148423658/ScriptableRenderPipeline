#pragma kernel CSVFXIndirectArgs

#include "HLSLSupport.cginc"

CBUFFER_START(Uniform)
	uint maxNb;
	uint offset;
CBUFFER_END
 
#define NB_THREADS_PER_GROUP 64

struct OutputData
{
	uint type;
	uint indexCount;
};

ByteAddressBuffer nbElements; // Filled by GPU
StructuredBuffer<OutputData> outputData; // Filled by CPU (TODO : rename)
RWBuffer<uint> output; //(TODO : rename)

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXIndirectArgs(uint3 id : SV_DispatchThreadID)
{
	uint index = id.x + offset;
	if (index < maxNb)
	{
		uint firstArg = 0u;
		uint secondArg = 0u;
		uint thirdArg = 0u;

		uint elementCount = nbElements.Load(index << 2);

		OutputData data = outputData[index];
		switch(data.type)
		{
			case 0: // point
			{
				firstArg = elementCount;
				secondArg = 1;
				break;
			}

			case 1: // lines
			{
				firstArg = elementCount * 2;
				secondArg = 1;
				break;
			}
			
			case 2: // quads
			{
				if (elementCount > 16384) // Due to 16bits indices (4 vertices per element)
				{
					const uint NB_PARTICLES_PER_INSTANCE = 2048;
					firstArg = NB_PARTICLES_PER_INSTANCE * 6;
					secondArg = (elementCount + (NB_PARTICLES_PER_INSTANCE - 1)) / NB_PARTICLES_PER_INSTANCE;
				}
				else
				{
					firstArg = elementCount * 6;
					secondArg = 1;
				}
				break;
			}
			
			case 3: // hexahedron
			{
				if (elementCount > 8192) // Due to 16bits indices (8 vertices per element)
				{
					const uint NB_PARTICLES_PER_INSTANCE = 1024;
					firstArg = NB_PARTICLES_PER_INSTANCE * 36;
					secondArg = (elementCount + (NB_PARTICLES_PER_INSTANCE - 1)) / NB_PARTICLES_PER_INSTANCE;
				}
				else
				{
					firstArg = elementCount * 36;
					secondArg = 1;
				}
				break;
			}

			case 4: // meshes
			{
				firstArg = data.indexCount;
				secondArg = elementCount;
				break;
			}
			case 0xffffffff: // dispatch
			{
				firstArg = (elementCount + NB_THREADS_PER_GROUP - 1) / NB_THREADS_PER_GROUP;
				secondArg = thirdArg = 1u;
				//todo => for spawnIndex
				break;
			}
		}

		uint indexOutput = index * 5;
		output[indexOutput + 0] = firstArg; //IndexCountPerInstance or ThreadGroupCountX
		output[indexOutput + 1] = secondArg; //InstanceCount or ThreadGroupCountY
		output[indexOutput + 2] = thirdArg; //startIndex or ThreadGroupCountz
		// 2 next uint (BaseVertex and StartInstance) set to 0 at initialization
	}
}
