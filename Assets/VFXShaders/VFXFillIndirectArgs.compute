#pragma kernel CSVFXIndirectArgs

#include "HLSLSupport.cginc"

CBUFFER_START(Uniform)
	uint maxNb;
	uint offset;
CBUFFER_END
 
#define NB_THREADS_PER_GROUP 64

struct InputData
{
	uint type;
	uint arg0; //indexCount for meshes
};

ByteAddressBuffer inputGpuBuffer;
StructuredBuffer<InputData> inputCpuBuffer;
RWBuffer<uint> outputIndirectArgs;
RWBuffer<uint> outputAdditional;

[numthreads(NB_THREADS_PER_GROUP,1,1)]
void CSVFXIndirectArgs(uint3 id : SV_DispatchThreadID)
{
	uint index = id.x + offset;
	if (index < maxNb)
	{
		uint elementCount = inputGpuBuffer.Load(index << 2);
		InputData data = inputCpuBuffer[index];
		
		uint firstArg = 0u;
		uint secondArg = 0u;
		uint thirdArg = 0u;
		
		switch(data.type)
		{
			case 0: // point
			{
				firstArg = elementCount;
				secondArg = 1;
				break;
			}

			case 1: // lines
			{
				firstArg = elementCount * 2;
				secondArg = 1;
				break;
			}
			
			case 2: // quads
			{
				if (elementCount > 16384) // Due to 16bits indices (4 vertices per element)
				{
					const uint NB_PARTICLES_PER_INSTANCE = 2048;
					firstArg = NB_PARTICLES_PER_INSTANCE * 6;
					secondArg = (elementCount + (NB_PARTICLES_PER_INSTANCE - 1)) / NB_PARTICLES_PER_INSTANCE;
				}
				else
				{
					firstArg = elementCount * 6;
					secondArg = 1;
				}
				break;
			}
			
			case 3: // hexahedron
			{
				if (elementCount > 8192) // Due to 16bits indices (8 vertices per element)
				{
					const uint NB_PARTICLES_PER_INSTANCE = 1024;
					firstArg = NB_PARTICLES_PER_INSTANCE * 36;
					secondArg = (elementCount + (NB_PARTICLES_PER_INSTANCE - 1)) / NB_PARTICLES_PER_INSTANCE;
				}
				else
				{
					firstArg = elementCount * 36;
					secondArg = 1;
				}
				break;
			}

			case 4: // meshes
			{
				firstArg = data.arg0;
				secondArg = elementCount;
				break;
			}
			case 0xffffffff: // dispatch
			{
				firstArg = (elementCount + NB_THREADS_PER_GROUP - 1) / NB_THREADS_PER_GROUP;
				firstArg = max(1u, firstArg); //WIP
				
				//Update total element count (spawnIndex)
				outputAdditional[index * 2 + 0] = elementCount;
				outputAdditional[index * 2 + 1] = outputAdditional[data.arg0 * 2 + 1] + elementCount;
				secondArg = thirdArg = 1u;
				break;
			}
		}

		uint indexOutput = index * 5;
		outputIndirectArgs[indexOutput + 0] = firstArg; //IndexCountPerInstance or ThreadGroupCountX
		outputIndirectArgs[indexOutput + 1] = secondArg; //InstanceCount or ThreadGroupCountY
		outputIndirectArgs[indexOutput + 2] = thirdArg; //startIndex or ThreadGroupCountz
		// 2 next uint (BaseVertex and StartInstance) set to 0 at initialization
	}
}
