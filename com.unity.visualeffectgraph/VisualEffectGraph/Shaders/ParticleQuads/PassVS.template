#pragma vertex vert
VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, uint instanceID : SV_InstanceID)
{
	uint index = (id >> 2) + instanceID * 2048;
	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
	if (index < asuint(nbMax))
	{
		#if VFX_HAS_INDIRECT_DRAW
		index = indirectBuffer[index];
		#endif
		${VFXLoadAttributes:{alive}}
		if (alive)
		{
			${VFXLoadAttributes:{(?!(alive))(\b\w)}}
			${VFXProcessBlocks}
			
			if (!alive)
				return o;
			
			o.VFX_VARYING_UV.x = float(id & 1);
			o.VFX_VARYING_UV.y = float((id & 2) >> 1);
			
			${VFXLoadSize}
			
			float4x4 elementToVFX = GetElementToVFXMatrix(axisX,axisY,axisZ,float3(angleX,angleY,angleZ),pivot,size,position);
			float3 vPos = mul(elementToVFX,float4(o.VFX_VARYING_UV.xy * 2.0f - 1.0f,0.0f,1.0f)).xyz;

			o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);

			${VFXVertexCommonProcess}
			
			#if USE_FLIPBOOK
			${VFXLoadParameter:{flipBookSize}}
			${VFXLoadParameter:{invFlipBookSize}}
			#if USE_FLIPBOOK_INTERPOLATION
			ProcessFlipBookUV(flipBookSize, invFlipBookSize, texIndex, o.VFX_VARYING_UV, o.VFX_VARYING_FRAMEBLEND);
			#else
			ProcessFlipBookUV(flipBookSize, invFlipBookSize, texIndex, o.VFX_VARYING_UV);
			#endif
			#endif

			${VFXVertexAdditionalProcess}
		}
	}
	return o;
}
