#---------------------------------------------------------------------
# AGE/LIFETIME BLOCKS
#---------------------------------------------------------------------

#block Set Lifetime (Constant)
#icon Time
#category Time/
#arg float lifetime [inout|param]
#arg float value [public]

lifetime = max(value,0.0f);

#block Set Lifetime (Random)
#icon Time
#category Time/
#arg float lifetime [inout|param]
#arg float minLifetime [public]
#arg float maxLifetime [public]

lifetime = max(minLifetime + RAND * (maxLifetime-minLifetime),0.0f);

#---------------------------------------------------------------------
# COLOR BLOCKS
#---------------------------------------------------------------------

#block Set Color (Constant)
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float3 value [public] 

color = value;

#block Color from Texture2D (XZ Projection)
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float3 position [param] 
#arg float textureworldsize [public]
#arg Texture2D tex [public] 

float2 coords = (position.xz / max(0.0001f,textureworldsize));
color = tex2Dlod(tex,float4(coords.x,coords.y,0,0)).rgb;;

#block Set Color (Random)
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float3 value1 [public] 
#arg float3 value2 [public] 

color = lerp(value1,value2,RAND);

#block Color Over Lifetime
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float age [param] 
#arg float lifetime [param] 
#arg float3 start [public] 
#arg float3 end [public] 

float ratio = saturate(age / lifetime);
color = lerp(start,end,ratio);

#block Color Over Lifetime (Texture)
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float age [param] 
#arg float lifetime [param] 
#arg Texture2D tex [public] 

float ratio = saturate(age / lifetime);
color = tex2Dlod(tex,float4(ratio,0.5,0,0)).rgb;

#block Set Alpha (Constant)
#icon Alpha
#category Color/
#arg float alpha [inout|param]
#arg float value [public] 

alpha = value;

#block Set Alpha (Random)
#icon Alpha
#category Color/
#arg float alpha [inout|param]
#arg float value1 [public] 
#arg float value2 [public] 

alpha = lerp(value1,value2,RAND);

#block Alpha Over Lifetime
#icon Alpha
#category Color/
#arg float alpha [inout|param]
#arg float age [param] 
#arg float lifetime [param] 
#arg float start [public] 
#arg float end [public] 

float ratio = saturate(age / lifetime);
alpha = lerp(start,end,ratio);

#block Phase To Color
#icon Color
#category Debug/
#arg float3 color [inout|param]
#arg float phase [param] 

color = float3(phase,1 - phase,0.0);

#---------------------------------------------------------------------
# FORCE BLOCKS
#---------------------------------------------------------------------

#block Apply Force
#icon Force
#category Forces/
#arg float3 velocity [inout|param]
#arg float3 force [public] 

velocity += force * deltaTime;

#block Apply Drag
#icon Drag
#category Forces/
#arg float3 velocity [inout|param]
#arg float multiplier [public]

velocity *= max(0.0,(1.0 - multiplier * deltaTime)); // drag - linear only

#block Apply VectorField Force
#icon VectorField
#category Forces/
#arg float3 position [param]
#arg float3 velocity [inout|param]
#arg Texture3D VectorField [public]

const float3 FIELD_SIZE = float3(5,5,5);
float3 vectorFieldCoord = (position / FIELD_SIZE) + float3(0.5,-0.0,0.5);
vectorFieldCoord.y = 1 - vectorFieldCoord.y;
vectorFieldCoord = min(float3(0.95,0.95,0.95),max(float3(0.05,0.05,0.05),vectorFieldCoord));
velocity += (VectorField.SampleLevel(samplerVectorField,vectorFieldCoord,0.0).xyz - 0.5) * 2 * 0.8;

#block Conform To Sphere
#icon Force
#category Forces/
#arg float3 velocity [inout|param]
#arg float3 position [param]
#arg float3 center [public]
#arg float radius [public]
#arg float attractionSpeed [public]
#arg float attractionForce [public]
#arg float stickForce [public]
#arg float stickDistance [public]

float3 dir = center - position;
float distToCenter = length(dir);
float distToSurface = distToCenter - radius;
dir /= distToCenter;
float spdNormal = dot(dir,velocity);
float ratio = smoothstep(0.0,stickDistance * 2.0,abs(distToSurface));
float tgtSpeed = sign(distToSurface) * attractionSpeed * ratio;
float deltaSpeed = tgtSpeed - spdNormal;
velocity += sign(deltaSpeed) * min(abs(deltaSpeed),deltaTime * lerp(stickForce,attractionForce,ratio)) * dir;


#block Vortex Field (Sphere)
#icon Force
#category Forces/
#arg float3 position [param]
#arg float3 velocity [inout|param]
#arg float3 center [public]
#arg float targetspeed [public]
#arg float radius [public]
#arg float attractiondistance [public]

float3 delta = center-position;
float3 up = cross(delta,velocity);
float3 tangent = normalize(cross(up,delta));
float dist = sqrt(dot(delta,delta));
float strength = 1.0f-saturate( (dist-radius) / attractiondistance+0.0001f);
velocity = lerp(velocity, tangent*targetspeed, strength);

#block Attractor
#icon Force
#category Forces/
#arg float3 position [param]
#arg float3 velocity [inout|param]
#arg float3 center [public]
#arg float force [public]
#arg float offset [public]

float3 dir = center - position;
float sqrDist = dot(dir,dir) + offset;
velocity += normalize(dir) * (deltaTime * force / sqrDist);

#---------------------------------------------------------------------
# POSITION BLOCKS
#---------------------------------------------------------------------

#block Set Position (Point)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 value [public] 

position = value;

#block Position Map (Texture)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg Texture2D tex [public] 
#arg float3 scale [public]
#arg float3 center [public]

position = center+((tex2Dlod(tex,float4(RAND,RAND,0,0)).rgb-0.5f)*scale);

#block Set Position (Random Box)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 minValue [public] 
#arg float3 maxValue [public] 

position = float3(  lerp(minValue.x,maxValue.x,RAND),
					lerp(minValue.y,maxValue.y,RAND),
					lerp(minValue.z,maxValue.z,RAND));

#TODO Factorize these 2 blocks when boolean switches are implemented !
					
#block Set Position (Sphere)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public] 

float u1 = 2.0 * RAND - 1.0;
float u2 = UNITY_TWO_PI * RAND;
float u3 = pow(RAND,1.0/3.0);
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
sincosTheta *= sqrt(1.0 - u1*u1);
position = float3(sincosTheta,u1) * (u3 * radius) + center;

#block Set Position (Sphere Surface)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public] 

float u1 = 2.0 * RAND - 1.0;
float u2 = UNITY_TWO_PI * RAND;
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
sincosTheta *= sqrt(1.0 - u1*u1);
position = (float3(sincosTheta,u1) * radius) + center;

#block Set Position (Cylinder)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public]
#arg float height [public]

float u1 = 1.0 * RAND - 0.5;
float u2 = UNITY_TWO_PI * RAND;
float u3 = sqrt(RAND);
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
position = (float3(sincosTheta * u3,u1 * height) * radius).xzy + center;

#block Set Position (Cylinder Surface)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public]
#arg float height [public]

float u1 = 1.0 * RAND - 0.5;
float u2 = UNITY_TWO_PI * RAND;
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
position = float3(sincosTheta * radius,u1 * height).xzy + center;


#---------------------------------------------------------------------
# COLLISION BLOCKS
#---------------------------------------------------------------------

#block Collision with Plane
#icon Position
#category Collision/
#arg float3 position [inout|param]
#arg float3 velocity [inout|param]
#arg float3 normal [public]
#arg float3 center [public]
#arg float elasticity [public]

const float EPSILON = 1e-5;

float3 n = normalize(normal); // TODO ensure normal is normalized prior to call
float3 nextPos = position + velocity * deltaTime;
float distToPlane0 = dot(n,position - center);
float distToPlane1 = dot(n,nextPos - center);

if (sign(distToPlane0) != sign(distToPlane1))
{
	float ratio = abs(distToPlane0) / (abs(distToPlane0) + abs(distToPlane1));
	//position = lerp(position,nextPos,ratio); // advance to collision
	velocity -= ((1 + elasticity) * dot(n,velocity)) * n;
	//position -= velocity * deltaTime * ratio; // remove part of the already resolved time
}

#---------------------------------------------------------------------
# SIZE BLOCKS
#---------------------------------------------------------------------

#block Set Size Constant (Square)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float value [public] 

size = float2(value,value);

#block Set Size Constant (Rectangle)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float2 value [public] 

size = value;

#block Set Size Random (Square)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float minSize [public] 
#arg float maxSize [public] 

float s = lerp(minSize,maxSize,RAND);
size = float2( s,s);

#block Apply Random Scale (Conserve Ratio)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float minScale [public] 
#arg float maxScale [public] 

float s = lerp(minScale,maxScale,RAND);
size *= s;

#block Apply Random Scale
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float2 minScale [public] 
#arg float2 maxScale [public] 

size *= float2(lerp(minScale.x,maxScale.x,RAND),lerp(minScale.y,maxScale.y,RAND));

#block Height Over Velocity
#icon Size
#category Size/
#arg float3 velocity [param]
#arg float2 size [inout|param]
#arg float multiplier [public]

size.y = length(velocity) * multiplier;

#---------------------------------------------------------------------
# VELOCITY BLOCKS
#---------------------------------------------------------------------

#block Set Velocity (Constant)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float3 value [public]

velocity = value;

#block Set Velocity (Random)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float3 base [public]
#arg float3 divergence [public] 

velocity = float3(	base.x + (RAND*2-1) * divergence.x,
					base.y + (RAND*2-1)  * divergence.y,
					base.z + (RAND*2-1)  * divergence.z);
					
#block Set Velocity (Spherical)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float2 angle [public]
#arg float2 speed [public]

float2 z = cos(radians(angle));
float u1 = lerp(z.x,z.y,RAND);
float u2 = UNITY_TWO_PI * RAND;
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
sincosTheta *= sqrt(1.0 - u1*u1);
velocity = float3(sincosTheta,u1).xzy * lerp(speed.x,speed.y,RAND);

#block Add Velocity (Constant)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float3 value [public]

velocity += value * deltaTime;

#---------------------------------------------------------------------
# COMMMON BLOCKS (UNCATEGORIZED)
#---------------------------------------------------------------------

#block Age and Reap
#icon Time
#category
#arg float age [inout|param]
#arg float lifetime [param]

age += deltaTime;
if (age >= lifetime)
	KILL;

#block Apply Velocity to Positions
#icon Position
#arg float3 position [inout|param]
#arg float3 velocity [param]

position += velocity * deltaTime;

#block Test Compile Failure
#icon Position
#category Tests/
#arg float test [public]

this wont compile !;

#block Test Missing Icon
#icon missing__
#category Tests/
#arg float test [public]

float a = 1; // Dummy
