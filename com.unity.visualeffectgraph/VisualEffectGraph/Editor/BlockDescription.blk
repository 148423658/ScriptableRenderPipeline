#---------------------------------------------------------------------
# AGE/LIFETIME BLOCKS
#---------------------------------------------------------------------

#block Set Lifetime (Constant)
#icon Time
#category Time/
#arg float lifetime [inout|param]
#arg float value [public]

lifetime = max(value,0.0f);

#block Set Lifetime (Random)
#icon Time
#category Time/
#arg float lifetime [inout|param]
#arg float minLifetime [public]
#arg float maxLifetime [public]

lifetime = max(minLifetime + RAND * (maxLifetime-minLifetime),0.0f);

#---------------------------------------------------------------------
# COLOR BLOCKS
#---------------------------------------------------------------------

#block Set Color (Constant)
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float3 value [public] 

color = value;

#block Set Color (Random)
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float3 value1 [public] 
#arg float3 value2 [public] 

color = lerp(value1,value2,RAND);

#block Color Over Lifetime
#icon Color
#category Color/
#arg float3 color [inout|param]
#arg float age [param] 
#arg float lifetime [param] 
#arg float3 start [public] 
#arg float3 end [public] 

float ratio = saturate(age / lifetime);
color = lerp(start,end,ratio);

#block Phase To Color
#icon Color
#category Debug/
#arg float3 color [inout|param]
#arg float phase [param] 

color = float3(phase,1 - phase,0.0); 

#---------------------------------------------------------------------
# FORCE BLOCKS
#---------------------------------------------------------------------

#block Apply Force
#icon Force
#category Forces/
#arg float3 velocity [inout|param]
#arg float3 force [public] 

velocity += force * deltaTime;

#block Apply Drag
#icon Drag
#category Forces/
#arg float3 velocity [inout|param]
#arg float multiplier [public]

velocity *= max(0.0,(1.0 - multiplier * deltaTime * dot(velocity,velocity))); // drag

#block Apply VectorField Force
#icon VectorField
#category Forces/
#arg float3 position [param]
#arg float3 velocity [inout|param]
#arg Texture3D VectorField [public]

const float3 FIELD_SIZE = float3(5,5,5);
float3 vectorFieldCoord = (position / FIELD_SIZE) + float3(0.5,-0.0,0.5);
vectorFieldCoord.y = 1 - vectorFieldCoord.y;
vectorFieldCoord = min(float3(0.95,0.95,0.95),max(float3(0.05,0.05,0.05),vectorFieldCoord));
velocity += (VectorField.SampleLevel(samplerVectorField,vectorFieldCoord,0.0).xyz - 0.5) * 2 * 0.8;

#block Attractor
#icon Force
#category Forces/
#arg float3 position [param]
#arg float3 velocity [inout|param]
#arg float3 center [public]
#arg float force [public]
#arg float offset [public]

float3 dir = center - position;
float sqrDist = dot(dir,dir) + offset;
velocity += normalize(dir) * (deltaTime * force / sqrDist);

#---------------------------------------------------------------------
# POSITION BLOCKS
#---------------------------------------------------------------------

#block Set Position (Point)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 value [public] 

position = value;

#block Set Position (Random Box)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 minValue [public] 
#arg float3 maxValue [public] 

position = float3(  lerp(minValue.x,maxValue.x,RAND),
					lerp(minValue.y,maxValue.y,RAND),
					lerp(minValue.z,maxValue.z,RAND));

#TODO Factorize these 2 blocks when boolean switches are implemented !
					
#block Set Position (Sphere)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public] 

float u1 = 2.0 * RAND - 1.0;
float u2 = UNITY_TWO_PI * RAND;
float u3 = pow(RAND,1.0/3.0);
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
sincosTheta *= sqrt(1.0 - u1*u1);
position = float3(sincosTheta,u1) * (u3 * radius) + center;

#block Set Position (Sphere Surface)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public] 

float u1 = 2.0 * RAND - 1.0;
float u2 = UNITY_TWO_PI * RAND;
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
sincosTheta *= sqrt(1.0 - u1*u1);
position = (float3(sincosTheta,u1) * radius) + center;

#block Set Position (Cylinder)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public]
#arg float height [public]

float u1 = 1.0 * RAND - 0.5;
float u2 = UNITY_TWO_PI * RAND;
float u3 = sqrt(RAND);
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
position = (float3(sincosTheta * u3,u1 * height) * radius).xzy + center;

#block Set Position (Cylinder Surface)
#icon Position
#category Position/
#arg float3 position [inout|param]
#arg float3 center [public] 
#arg float radius [public]
#arg float height [public]

float u1 = 1.0 * RAND - 0.5;
float u2 = UNITY_TWO_PI * RAND;
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
position = float3(sincosTheta * radius,u1 * height).xzy + center;


#---------------------------------------------------------------------
# COLLISION BLOCKS
#---------------------------------------------------------------------

#block Collision with Plane
#icon Position
#category Collision/
#arg float3 position [param]
#arg float3 velocity [inout|param]
#arg float3 normal [public]
#arg float3 center [public]
#arg float elasticity [public]

const float EPSILON = 1e-5;

float3 n = normalize(normal); // TODO ensure normal is normalized prior to call
float distToPlane = dot(n,position - center);
float projectedVelocity = dot(n,velocity);

if (sign(projectedVelocity) != sign(distToPlane) && deltaTime * abs(projectedVelocity) + EPSILON > abs(distToPlane))
	velocity -= ((1 + elasticity) * projectedVelocity) * n; // Collision

#---------------------------------------------------------------------
# SIZE BLOCKS
#---------------------------------------------------------------------

#block Set Size Constant (Square)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float value [public] 

size = float2(value,value);

#block Set Size Constant (Rectangle)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float2 value [public] 

size = value;

#block Set Size Random (Square)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float minSize [public] 
#arg float maxSize [public] 

float s = lerp(minSize,maxSize,RAND);
size = float2( s,s);

#block Apply Random Scale (Conserve Ratio)
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float minScale [public] 
#arg float maxScale [public] 

float s = lerp(minScale,maxScale,RAND);
size *= s;

#block Apply Random Scale
#icon Size
#category Size/
#arg float2 size [inout|param]
#arg float2 minScale [public] 
#arg float2 maxScale [public] 

size *= float2(lerp(minScale.x,maxScale.x,RAND),lerp(minScale.y,maxScale.y,RAND));

#---------------------------------------------------------------------
# VELOCITY BLOCKS
#---------------------------------------------------------------------

#block Set Velocity (Constant)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float3 value [public]

velocity = value;

#block Set Velocity (Random)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float offset [public]
#arg float multiplier [public] 

velocity = float3(	offset + RAND * multiplier,
					offset + RAND * multiplier,
					offset + RAND * multiplier);
					
#block Set Velocity (Spherical)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float2 angle [public]
#arg float2 speed [public]

float2 z = cos(radians(angle));
float u1 = lerp(z.x,z.y,RAND);
float u2 = UNITY_TWO_PI * RAND;
float2 sincosTheta;
sincos(u2,sincosTheta.x,sincosTheta.y);
sincosTheta *= sqrt(1.0 - u1*u1);
velocity = float3(sincosTheta,u1).xzy * lerp(speed.x,speed.y,RAND);

#block Add Velocity (Constant)
#icon Velocity
#category Velocity/
#arg float3 velocity [inout|param]
#arg float3 value [public]

velocity += value * deltaTime;

#---------------------------------------------------------------------
# COMMMON BLOCKS (UNCATEGORIZED)
#---------------------------------------------------------------------

#block Age and Reap
#icon Time
#category
#arg float age [inout|param]
#arg float lifetime [param]

age += deltaTime;
if (age >= lifetime)
	KILL;

#block Apply Velocity to Positions
#icon Position
#arg float3 position [inout|param]
#arg float3 velocity [param]

position += velocity * deltaTime;

#block Test Compile Failure
#icon Position
#category Tests/
#arg float test [public]

this wont compile !;

#block Test Missing Icon
#icon missing__
#category Tests/
#arg float test [public]

float a = 1; // Dummy
